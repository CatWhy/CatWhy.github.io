{
    "version": "https://jsonfeed.org/version/1",
    "title": "独白 • All posts by \"原型模式\" tag",
    "description": "博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/09/19/javascript-chang-yong-ba-chong-ji-cheng-fang-shi/",
            "url": "http://example.com/2022/09/19/javascript-chang-yong-ba-chong-ji-cheng-fang-shi/",
            "title": "JavaScript常用八种继承方式",
            "date_published": "2022-09-19T12:58:50.000Z",
            "content_html": "<h1 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h1><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。<br>继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperType() {</span><br><span class=\"line\">    this.property = true;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getSuperValue = function() {</span><br><span class=\"line\">    return this.property;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">function SubType() {</span><br><span class=\"line\">    this.subproperty = false;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span><br><span class=\"line\">SubType.prototype = new SuperType(); </span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.getSubValue = function() {</span><br><span class=\"line\">    return this.subproperty;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">var instance = new SubType();</span><br><span class=\"line\">console.log(instance.getSuperValue()); // true</span><br></pre></td></tr></tbody></table></figure>\n<p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperType(){</span><br><span class=\"line\">  this.colors = [\"red\", \"blue\", \"green\"];</span><br><span class=\"line\">}</span><br><span class=\"line\">function SubType(){}</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = new SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\">var instance1 = new SubType();</span><br><span class=\"line\">instance1.colors.push(\"black\");</span><br><span class=\"line\">alert(instance1.colors); //\"red,blue,green,black\"</span><br><span class=\"line\"></span><br><span class=\"line\">var instance2 = new SubType(); </span><br><span class=\"line\">alert(instance2.colors); //\"red,blue,green,black\"</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"借用构造函数继承-借调）\"><a href=\"#借用构造函数继承-借调）\" class=\"headerlink\" title=\"借用构造函数继承(借调）\"></a>借用构造函数继承(借调）</h1><p>借调：借用构造函数调用冒充继承，借调实现的继承，不是真正的继承，只是借用构造函数中的属性或方法。<br>即：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function  SuperType(){</span><br><span class=\"line\">    this.color=[\"red\",\"green\",\"blue\"];</span><br><span class=\"line\">}</span><br><span class=\"line\">function  SubType(){</span><br><span class=\"line\">    //继承自SuperType</span><br><span class=\"line\">    SuperType.call(this);</span><br><span class=\"line\">}</span><br><span class=\"line\">var instance1 = new SubType();</span><br><span class=\"line\">instance1.color.push(\"black\");</span><br><span class=\"line\">alert(instance1.color);//\"red,green,blue,black\"</span><br><span class=\"line\"></span><br><span class=\"line\">var instance2 = new SubType();</span><br><span class=\"line\">alert(instance2.color);//\"red,green,blue\"</span><br></pre></td></tr></tbody></table></figure>\n<p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将SuperType中的属性复制一份。<br>缺点：<br>● 只能继承父类的实例属性和方法，不能继承原型属性/方法<br>● 无法实现复用，每个子类都有父类实例函数的副本，影响性能</p>\n<h1 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h1><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function SuperType(name){</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.colors = [\"red\", \"blue\", \"green\"];</span><br><span class=\"line\">}</span><br><span class=\"line\">SuperType.prototype.sayName = function(){</span><br><span class=\"line\">  alert(this.name);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">function SubType(name, age){</span><br><span class=\"line\">  // 继承属性</span><br><span class=\"line\">  // 第二次调用SuperType()</span><br><span class=\"line\">  SuperType.call(this, name);</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承方法</span><br><span class=\"line\">// 构建原型链</span><br><span class=\"line\">// 第一次调用SuperType()</span><br><span class=\"line\">SubType.prototype = new SuperType(); </span><br><span class=\"line\">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span><br><span class=\"line\">SubType.prototype.constructor = SubType; </span><br><span class=\"line\">SubType.prototype.sayAge = function(){</span><br><span class=\"line\">    alert(this.age);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">var instance1 = new SubType(\"Nicholas\", 29);</span><br><span class=\"line\">instance1.colors.push(\"black\");</span><br><span class=\"line\">alert(instance1.colors); //\"red,blue,green,black\"</span><br><span class=\"line\">instance1.sayName(); //\"Nicholas\";</span><br><span class=\"line\">instance1.sayAge(); //29</span><br><span class=\"line\"></span><br><span class=\"line\">var instance2 = new SubType(\"Greg\", 27);</span><br><span class=\"line\">alert(instance2.colors); //\"red,blue,green\"</span><br><span class=\"line\">instance2.sayName(); //\"Greg\";</span><br><span class=\"line\">instance2.sayAge(); //27</span><br></pre></td></tr></tbody></table></figure>\n<p>缺点：<br>● 第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性name，color。<br>● 第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性name，color。<br>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p>\n<h1 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h1><p>原理：类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的__proto__指向父对象<br>1.利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(obj){</span><br><span class=\"line\">  function F(){}</span><br><span class=\"line\">  F.prototype = obj;</span><br><span class=\"line\">  return new F();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>object()对传入其中的对象执行了一次<code>浅复制</code>，将构造函数F的原型直接指向传入的对象。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = {</span><br><span class=\"line\">  name: \"Nicholas\",</span><br><span class=\"line\">  friends: [\"Shelby\", \"Court\", \"Van\"]</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">var anotherPerson = object(person);</span><br><span class=\"line\">anotherPerson.name = \"Greg\";</span><br><span class=\"line\">anotherPerson.friends.push(\"Rob\");</span><br><span class=\"line\"></span><br><span class=\"line\">var yetAnotherPerson = object(person);</span><br><span class=\"line\">yetAnotherPerson.name = \"Linda\";</span><br><span class=\"line\">yetAnotherPerson.friends.push(\"Barbie\");</span><br><span class=\"line\"></span><br><span class=\"line\">alert(person.friends);   //\"Shelby,Court,Van,Rob,Barbie\"</span><br></pre></td></tr></tbody></table></figure>\n<p>2.或者直接利用Object.create():</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person = {</span><br><span class=\"line\">  name: \"Nicholas\",</span><br><span class=\"line\">  friends: [\"Shelby\", \"Court\", \"Van\"]</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">let anotherPerson = Object.create(person);</span><br><span class=\"line\">anotherPerson.name = \"Greg\";</span><br><span class=\"line\">anotherPerson.friends.push(\"Rob\");</span><br><span class=\"line\"></span><br><span class=\"line\">let yetAnotherPerson = Object.create(person);</span><br><span class=\"line\">yetAnotherPerson.name = \"Linda\";</span><br><span class=\"line\">yetAnotherPerson.friends.push(\"Barbie\");</span><br><span class=\"line\"></span><br><span class=\"line\">alert(person.friends);   //\"Shelby,Court,Van,Rob,Barbie\"</span><br></pre></td></tr></tbody></table></figure>\n\n<p>优点：<br>● 父类方法可以复用<br>缺点：<br>● 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能<br>● 子类构建实例时不能向父类传递参数</p>\n<h1 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h1><p>核心：在原型式继承的基础上，增强对象，返回构造函数<br>即：使用原型式继承获得一份目标对象的浅拷贝，然后增强了这个浅拷贝的能力。<br>优缺点其实和原型式继承一样，寄生式继承说白了就是能在拷贝来的对象上加点方法，也就是所谓增强能力。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(obj) {</span><br><span class=\"line\">  function F() { }</span><br><span class=\"line\">  F.prototype = obj</span><br><span class=\"line\">  return new F()</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">function createAnother(original){</span><br><span class=\"line\">  var clone = object(original); // 通过调用 object() 函数创建一个新对象</span><br><span class=\"line\">  clone.sayHi = function(){  // 以某种方式来增强对象</span><br><span class=\"line\">    alert(\"hi\");</span><br><span class=\"line\">  };</span><br><span class=\"line\">  return clone; // 返回这个对象</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = {</span><br><span class=\"line\">  name: \"Nicholas\",</span><br><span class=\"line\">  friends: [\"Shelby\", \"Court\", \"Van\"]</span><br><span class=\"line\">};</span><br><span class=\"line\">var anotherPerson = createAnother(person);</span><br><span class=\"line\">anotherPerson.sayHi(); //\"hi\"</span><br></pre></td></tr></tbody></table></figure>\n<p>缺点（同原型式继承）：<br>● 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。<br>● 无法传递参数</p>\n<h1 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h1><p>结合借用构造函数传递参数和寄生模式实现继承</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritPrototype(subType, superType){</span><br><span class=\"line\">  // 创建对象，创建父类原型的一个副本</span><br><span class=\"line\">  var prototype = Object.create(superType.prototype); </span><br><span class=\"line\">  // 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br><span class=\"line\">  prototype.constructor = subType;  </span><br><span class=\"line\">  // 指定对象，将新创建的对象赋值给子类的原型</span><br><span class=\"line\">  subType.prototype = prototype;                      </span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">// 父类初始化实例属性和原型属性</span><br><span class=\"line\">function SuperType(name){</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.colors = [\"red\", \"blue\", \"green\"];</span><br><span class=\"line\">}</span><br><span class=\"line\">SuperType.prototype.sayName = function(){</span><br><span class=\"line\">  alert(this.name);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><br><span class=\"line\">function SubType(name, age){</span><br><span class=\"line\">  SuperType.call(this, name);</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">// 将父类原型指向子类</span><br><span class=\"line\">inheritPrototype(SubType, SuperType);</span><br><span class=\"line\"></span><br><span class=\"line\">// 新增子类原型属性</span><br><span class=\"line\">SubType.prototype.sayAge = function(){</span><br><span class=\"line\">  alert(this.age);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">var instance1 = new SubType(\"xyc\", 23);</span><br><span class=\"line\">var instance2 = new SubType(\"lxy\", 23);</span><br><span class=\"line\"></span><br><span class=\"line\">instance1.colors.push(\"2\"); // [\"red\", \"blue\", \"green\", \"2\"]</span><br><span class=\"line\">instance2.colors.push(\"3\"); // [\"red\", \"blue\", \"green\", \"3\"]</span><br></pre></td></tr></tbody></table></figure>\n<p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof </code>和<code>isPrototypeOf()</code><br>这是最成熟的方法，也是现在库实现的方法</p>\n<h1 id=\"混入方式继承多个对象\"><a href=\"#混入方式继承多个对象\" class=\"headerlink\" title=\"混入方式继承多个对象\"></a>混入方式继承多个对象</h1><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyClass() {</span><br><span class=\"line\">     SuperClass.call(this);</span><br><span class=\"line\">     OtherSuperClass.call(this);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承一个类</span><br><span class=\"line\">MyClass.prototype = Object.create(SuperClass.prototype);</span><br><span class=\"line\">// 混合其它</span><br><span class=\"line\">Object.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class=\"line\">// 重新指定constructor</span><br><span class=\"line\">MyClass.prototype.constructor = MyClass;</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass.prototype.myMethod = function() {</span><br><span class=\"line\">     // do something</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p><code>Object.assign</code>会把 <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p>\n<h1 id=\"ES6类继承extends\"><a href=\"#ES6类继承extends\" class=\"headerlink\" title=\"ES6类继承extends\"></a>ES6类继承extends</h1><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的<br><code>constructor</code>方法，使用例子如下。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Rectangle {</span><br><span class=\"line\">    // constructor</span><br><span class=\"line\">    constructor(height, width) {</span><br><span class=\"line\">        this.height = height;</span><br><span class=\"line\">        this.width = width;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Getter</span><br><span class=\"line\">    get area() {</span><br><span class=\"line\">        return this.calcArea()</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Method</span><br><span class=\"line\">    calcArea() {</span><br><span class=\"line\">        return this.height * this.width;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">const rectangle = new Rectangle(10, 20);</span><br><span class=\"line\">console.log(rectangle.area);</span><br><span class=\"line\">// 输出 200</span><br><span class=\"line\"></span><br><span class=\"line\">-----------------------------------------------------------------</span><br><span class=\"line\">// 继承</span><br><span class=\"line\">class Square extends Rectangle {</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(length) {</span><br><span class=\"line\">    super(length, length);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class=\"line\">    this.name = 'Square';</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  get area() {</span><br><span class=\"line\">    return this.height * this.width;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">const square = new Square(10);</span><br><span class=\"line\">console.log(square.area);</span><br><span class=\"line\">// 输出 100</span><br></pre></td></tr></tbody></table></figure>\n<p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function _inherits(subType, superType) {</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 创建对象，创建父类原型的一个副本</span><br><span class=\"line\">    // 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br><span class=\"line\">    // 指定对象，将新创建的对象赋值给子类的原型</span><br><span class=\"line\">    subType.prototype = Object.create(superType &amp;&amp; superType.prototype, {</span><br><span class=\"line\">        constructor: {</span><br><span class=\"line\">            value: subType,</span><br><span class=\"line\">            enumerable: false,</span><br><span class=\"line\">            writable: true,</span><br><span class=\"line\">            configurable: true</span><br><span class=\"line\">        }</span><br><span class=\"line\">    });</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (superType) {</span><br><span class=\"line\">        Object.setPrototypeOf </span><br><span class=\"line\">            ? Object.setPrototypeOf(subType, superType) </span><br><span class=\"line\">            : subType.__proto__ = superType;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>",
            "tags": [
                "javascript",
                "原型模式",
                "前端"
            ]
        }
    ]
}