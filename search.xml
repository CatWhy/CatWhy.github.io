<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ElementUI 之 Cascader 级联选择器指定 value label</title>
    <url>/2022/09/19/elementui-zhi-cascader-ji-lian-xuan-ze-qi-zhi-ding-value-label/</url>
    <content><![CDATA[<p>ElementUI 的 Cascader 级联选择器对 :options=”options” 里的数据格式是有特定要求的：input 框显示的值是 options 里的 label 值。如果 options 的键值对不是 value label ，就需要 props 来配置。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;el-cascader</span><br><span class="line"> ref="cascader"</span><br><span class="line">    v-model="companyForm.industry"</span><br><span class="line">    style="width: 500px; "</span><br><span class="line">    :options="belongIndustry"</span><br><span class="line">    :props="{ multiple: true, emitPath:false }"</span><br><span class="line">    :clearable="true"</span><br><span class="line">    @change="nodeValue"</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">export default { </span><br><span class="line">　　data() {</span><br><span class="line">　　　　belongIndustry:[</span><br><span class="line">　　　　　　{ id: 1, name: '第一层', children: [ id: 11, name: '水果']},</span><br><span class="line">　　　　　　{ id: 2, name: '第二层', children: [ id: 22, name: '蔬菜'] },</span><br><span class="line">　　　　]</span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/bbb2df70a4a2492e9fa2f83901c8405a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
]]></content>
      <tags>
        <tag>elementui</tag>
        <tag>vue.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的内存溢出和内存泄露</title>
    <url>/2022/09/19/javascript-zhong-de-nei-cun-yi-chu-he-nei-cun-xie-lu/</url>
    <content><![CDATA[<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><ul>
<li>概念：一种程序运行出现的错误，当程序运行需要的内存超过了剩余的内存时，就出抛出内存溢出的错误。</li>
<li>举例：<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var obj = {}</span><br><span class="line">for (var i = 0; i &lt; 10000; i++) {</span><br><span class="line">	obj[i] = new Array(1000000000)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<img src="https://img-blog.csdnimg.cn/2a7712a5634d4d2e9a9380eef6f28115.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center"></li>
</ul>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>概念：占用的内存没有及时释放，内存泄露积累多了就容易导致内存溢出。</p>
<ul>
<li>常见的内存泄露:<br>（1）意外的全局变量<br>（2）没有及时清理的计时器或回调函数*闭包</li>
<li>举例：<br>（1）意外的全局变量<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function fn() {</span><br><span class="line">	a= 3</span><br><span class="line">	console.log(a)</span><br><span class="line">}</span><br><span class="line">fn()</span><br><span class="line">// fn() = null</span><br></pre></td></tr></tbody></table></figure>
（2）启动循环定时器后不清理<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var intervalId = setInterval(function () {</span><br><span class="line">	console.log( '----')</span><br><span class="line">}, 1000)</span><br><span class="line">// cLearInterval(intervaLId)</span><br></pre></td></tr></tbody></table></figure>
（3）闭包，不及时释放<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function fn1() {</span><br><span class="line">	var a = 4</span><br><span class="line">	function fn2() {</span><br><span class="line">		console.log(++a)</span><br><span class="line">	}</span><br><span class="line">	return fn2</span><br><span class="line">}</span><br><span class="line">var f = fn1()</span><br><span class="line">f()</span><br><span class="line">// f = nulL</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>开发语言</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript常用八种继承方式</title>
    <url>/2022/09/19/javascript-chang-yong-ba-chong-ji-cheng-fang-shi/</url>
    <content><![CDATA[<h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。<br>继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function SuperType() {</span><br><span class="line">    this.property = true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function() {</span><br><span class="line">    return this.property;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function SubType() {</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = function() {</span><br><span class="line">    return this.subproperty;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">console.log(instance.getSuperValue()); // true</span><br></pre></td></tr></tbody></table></figure>
<p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function SuperType(){</span><br><span class="line">  this.colors = ["red", "blue", "green"];</span><br><span class="line">}</span><br><span class="line">function SubType(){}</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push("black");</span><br><span class="line">alert(instance1.colors); //"red,blue,green,black"</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(); </span><br><span class="line">alert(instance2.colors); //"red,blue,green,black"</span><br></pre></td></tr></tbody></table></figure>

<h1 id="借用构造函数继承-借调）"><a href="#借用构造函数继承-借调）" class="headerlink" title="借用构造函数继承(借调）"></a>借用构造函数继承(借调）</h1><p>借调：借用构造函数调用冒充继承，借调实现的继承，不是真正的继承，只是借用构造函数中的属性或方法。<br>即：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function  SuperType(){</span><br><span class="line">    this.color=["red","green","blue"];</span><br><span class="line">}</span><br><span class="line">function  SubType(){</span><br><span class="line">    //继承自SuperType</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">}</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.color.push("black");</span><br><span class="line">alert(instance1.color);//"red,green,blue,black"</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.color);//"red,green,blue"</span><br></pre></td></tr></tbody></table></figure>
<p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将SuperType中的属性复制一份。<br>缺点：<br>● 只能继承父类的实例属性和方法，不能继承原型属性/方法<br>● 无法实现复用，每个子类都有父类实例函数的副本，影响性能</p>
<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function SuperType(name){</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = ["red", "blue", "green"];</span><br><span class="line">}</span><br><span class="line">SuperType.prototype.sayName = function(){</span><br><span class="line">  alert(this.name);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">function SubType(name, age){</span><br><span class="line">  // 继承属性</span><br><span class="line">  // 第二次调用SuperType()</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line">  this.age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 继承方法</span><br><span class="line">// 构建原型链</span><br><span class="line">// 第一次调用SuperType()</span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = function(){</span><br><span class="line">    alert(this.age);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType("Nicholas", 29);</span><br><span class="line">instance1.colors.push("black");</span><br><span class="line">alert(instance1.colors); //"red,blue,green,black"</span><br><span class="line">instance1.sayName(); //"Nicholas";</span><br><span class="line">instance1.sayAge(); //29</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType("Greg", 27);</span><br><span class="line">alert(instance2.colors); //"red,blue,green"</span><br><span class="line">instance2.sayName(); //"Greg";</span><br><span class="line">instance2.sayAge(); //27</span><br></pre></td></tr></tbody></table></figure>
<p>缺点：<br>● 第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性name，color。<br>● 第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性name，color。<br>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p>
<h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><p>原理：类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的__proto__指向父对象<br>1.利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function object(obj){</span><br><span class="line">  function F(){}</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  return new F();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>object()对传入其中的对象执行了一次<code>浅复制</code>，将构造函数F的原型直接指向传入的对象。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var person = {</span><br><span class="line">  name: "Nicholas",</span><br><span class="line">  friends: ["Shelby", "Court", "Van"]</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">var anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = "Greg";</span><br><span class="line">anotherPerson.friends.push("Rob");</span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = "Linda";</span><br><span class="line">yetAnotherPerson.friends.push("Barbie");</span><br><span class="line"></span><br><span class="line">alert(person.friends);   //"Shelby,Court,Van,Rob,Barbie"</span><br></pre></td></tr></tbody></table></figure>
<p>2.或者直接利用Object.create():</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">let person = {</span><br><span class="line">  name: "Nicholas",</span><br><span class="line">  friends: ["Shelby", "Court", "Van"]</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">let anotherPerson = Object.create(person);</span><br><span class="line">anotherPerson.name = "Greg";</span><br><span class="line">anotherPerson.friends.push("Rob");</span><br><span class="line"></span><br><span class="line">let yetAnotherPerson = Object.create(person);</span><br><span class="line">yetAnotherPerson.name = "Linda";</span><br><span class="line">yetAnotherPerson.friends.push("Barbie");</span><br><span class="line"></span><br><span class="line">alert(person.friends);   //"Shelby,Court,Van,Rob,Barbie"</span><br></pre></td></tr></tbody></table></figure>

<p>优点：<br>● 父类方法可以复用<br>缺点：<br>● 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能<br>● 子类构建实例时不能向父类传递参数</p>
<h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p>核心：在原型式继承的基础上，增强对象，返回构造函数<br>即：使用原型式继承获得一份目标对象的浅拷贝，然后增强了这个浅拷贝的能力。<br>优缺点其实和原型式继承一样，寄生式继承说白了就是能在拷贝来的对象上加点方法，也就是所谓增强能力。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function object(obj) {</span><br><span class="line">  function F() { }</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function createAnother(original){</span><br><span class="line">  var clone = object(original); // 通过调用 object() 函数创建一个新对象</span><br><span class="line">  clone.sayHi = function(){  // 以某种方式来增强对象</span><br><span class="line">    alert("hi");</span><br><span class="line">  };</span><br><span class="line">  return clone; // 返回这个对象</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var person = {</span><br><span class="line">  name: "Nicholas",</span><br><span class="line">  friends: ["Shelby", "Court", "Van"]</span><br><span class="line">};</span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); //"hi"</span><br></pre></td></tr></tbody></table></figure>
<p>缺点（同原型式继承）：<br>● 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。<br>● 无法传递参数</p>
<h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><p>结合借用构造函数传递参数和寄生模式实现继承</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function inheritPrototype(subType, superType){</span><br><span class="line">  // 创建对象，创建父类原型的一个副本</span><br><span class="line">  var prototype = Object.create(superType.prototype); </span><br><span class="line">  // 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br><span class="line">  prototype.constructor = subType;  </span><br><span class="line">  // 指定对象，将新创建的对象赋值给子类的原型</span><br><span class="line">  subType.prototype = prototype;                      </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 父类初始化实例属性和原型属性</span><br><span class="line">function SuperType(name){</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = ["red", "blue", "green"];</span><br><span class="line">}</span><br><span class="line">SuperType.prototype.sayName = function(){</span><br><span class="line">  alert(this.name);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><br><span class="line">function SubType(name, age){</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line">  this.age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 将父类原型指向子类</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">// 新增子类原型属性</span><br><span class="line">SubType.prototype.sayAge = function(){</span><br><span class="line">  alert(this.age);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType("xyc", 23);</span><br><span class="line">var instance2 = new SubType("lxy", 23);</span><br><span class="line"></span><br><span class="line">instance1.colors.push("2"); // ["red", "blue", "green", "2"]</span><br><span class="line">instance2.colors.push("3"); // ["red", "blue", "green", "3"]</span><br></pre></td></tr></tbody></table></figure>
<p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof </code>和<code>isPrototypeOf()</code><br>这是最成熟的方法，也是现在库实现的方法</p>
<h1 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function MyClass() {</span><br><span class="line">     SuperClass.call(this);</span><br><span class="line">     OtherSuperClass.call(this);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 继承一个类</span><br><span class="line">MyClass.prototype = Object.create(SuperClass.prototype);</span><br><span class="line">// 混合其它</span><br><span class="line">Object.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line">// 重新指定constructor</span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = function() {</span><br><span class="line">     // do something</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><code>Object.assign</code>会把 <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p>
<h1 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h1><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的<br><code>constructor</code>方法，使用例子如下。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Rectangle {</span><br><span class="line">    // constructor</span><br><span class="line">    constructor(height, width) {</span><br><span class="line">        this.height = height;</span><br><span class="line">        this.width = width;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // Getter</span><br><span class="line">    get area() {</span><br><span class="line">        return this.calcArea()</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // Method</span><br><span class="line">    calcArea() {</span><br><span class="line">        return this.height * this.width;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const rectangle = new Rectangle(10, 20);</span><br><span class="line">console.log(rectangle.area);</span><br><span class="line">// 输出 200</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">// 继承</span><br><span class="line">class Square extends Rectangle {</span><br><span class="line"></span><br><span class="line">  constructor(length) {</span><br><span class="line">    super(length, length);</span><br><span class="line">    </span><br><span class="line">    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line">    this.name = 'Square';</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  get area() {</span><br><span class="line">    return this.height * this.width;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const square = new Square(10);</span><br><span class="line">console.log(square.area);</span><br><span class="line">// 输出 100</span><br></pre></td></tr></tbody></table></figure>
<p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function _inherits(subType, superType) {</span><br><span class="line">  </span><br><span class="line">    // 创建对象，创建父类原型的一个副本</span><br><span class="line">    // 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br><span class="line">    // 指定对象，将新创建的对象赋值给子类的原型</span><br><span class="line">    subType.prototype = Object.create(superType &amp;&amp; superType.prototype, {</span><br><span class="line">        constructor: {</span><br><span class="line">            value: subType,</span><br><span class="line">            enumerable: false,</span><br><span class="line">            writable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    if (superType) {</span><br><span class="line">        Object.setPrototypeOf </span><br><span class="line">            ? Object.setPrototypeOf(subType, superType) </span><br><span class="line">            : subType.__proto__ = superType;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>React生命周期</title>
    <url>/2022/09/19/react-sheng-ming-zhou-qi/</url>
    <content><![CDATA[<h1 id="组件的挂载："><a href="#组件的挂载：" class="headerlink" title="组件的挂载："></a>组件的挂载：</h1><p>组件在首次创建后，进行第一次的渲染为挂载期。挂载期有的一些方法会被依次触发，列举如下：</p>
<p>constructor(构造函数，初始化状态值)<br>getInitialState(设置状态机)<br>getDefaultProps(获取默认的props)<br>UNSAFE_componentWillMount(首次渲染前执行)<br>render(渲染组件)<br>componentDidMount(render渲染之后执行的操作)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//组件挂载</span><br><span class="line">import React from 'react';</span><br><span class="line">import ReactDOM from 'react-dom';</span><br><span class="line">class HelloWorld extends React.Component{</span><br><span class="line">    constructor(props) {</span><br><span class="line">        super(props);</span><br><span class="line">        console.log("1,构造函数");</span><br><span class="line">        this.state={};</span><br><span class="line">        console.log("2,设置状态机");</span><br><span class="line">    }</span><br><span class="line">    static defaultProps={</span><br><span class="line">        name:"React",</span><br><span class="line">    }</span><br><span class="line">    UNSAFE_componentWillMount(nextProps, nextState, nextContext) {</span><br><span class="line">        console.log("3,完成首次渲染前调用");</span><br><span class="line">    }</span><br><span class="line">    render() {</span><br><span class="line">        console.log("4,组件进行渲染");</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;{this.props.name}&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">    componentDidMount() {</span><br><span class="line">        console.log("5,componentDidMount render渲染后的操作")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">ReactDOM.render(&lt;HelloWorld /&gt;, document.getElementById('root'));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/92c5df910cf6453698049a57fb6fd65c.png"></p>
<h1 id="组件的更新："><a href="#组件的更新：" class="headerlink" title="组件的更新："></a>组件的更新：</h1><p>组件更新，指的是在组件初次渲染后，进行了组件状态的改变。React在生命周期中的更新过程包括以下几个方法：</p>
<ul>
<li>UNSAFE_componentWillReceiveProps :当父组件更新子组件state时，该方法会被调用。</li>
<li>shouldComponentUpdate ： 该方法决定组件state或props的改变是否需要重新渲染组件。</li>
<li>UNSAFE_componentWillUpdate : 在组件接受新的state或者props时，即将进行重新渲染前调用该方法，和UNSAFE_componentWillMount方法类似。</li>
<li>componentDidUpdate : 在组件重新渲染后调用该方法，和componentDidMount方法类似。<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> //组件更新</span><br><span class="line">class HelloWorldFather extends React.Component{</span><br><span class="line">    constructor(props) {</span><br><span class="line">        super(props);</span><br><span class="line">        this.updateChildProps=this.updateChildProps.bind(this);</span><br><span class="line">        this.state={  //初始化父组件</span><br><span class="line">            name:"React"</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    updateChildProps(){  //更新父组件state</span><br><span class="line">        this.setState({</span><br><span class="line">            name:"Vue"</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">    render() {</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;HelloWorld name={this.state.name} /&gt;  {/*父组件的state传递给子组件*/}</span><br><span class="line">                &lt;button onClick={this.updateChildProps}&gt;更新子组件props&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">class HelloWorld extends React.Component{</span><br><span class="line">    constructor(props) {</span><br><span class="line">        super(props);</span><br><span class="line">        console.log("1,构造函数");</span><br><span class="line">        console.log("2,设置状态机")</span><br><span class="line">    }</span><br><span class="line">    UNSAFE_componentWillMount() {</span><br><span class="line">        console.log("3,完成首次渲染前调用");</span><br><span class="line">    }</span><br><span class="line">    UNSAFE_componentWillReceiveProps(nextProps, nextContext) {</span><br><span class="line">        console.log("6,父组件更新子组件时调用该方法");</span><br><span class="line">    }</span><br><span class="line">    shouldComponentUpdate(nextProps, nextState, nextContext) {</span><br><span class="line">        console.log("7,决定组件props或者state的改变是否需要重新进行渲染");</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    UNSAFE_componentWillUpdate(nextProps, nextState, nextContext) {</span><br><span class="line">        console.log("8,当接收到新的props或state时，调用该方法");</span><br><span class="line">    }</span><br><span class="line">    render() {</span><br><span class="line">        console.log("4,组件进行渲染");</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;{this.props.name}&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">    componentDidMount() {</span><br><span class="line">        console.log("5,componentDidMount render后的操作");</span><br><span class="line">    }</span><br><span class="line">    componentDidUpdate(prevProps, prevState, snapshot) {</span><br><span class="line">        console.log("9,组件被重新选然后调用该方法");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">ReactDOM.render(&lt;HelloWorldFather /&gt;,document.getElementById("root"));</span><br></pre></td></tr></tbody></table></figure>
<img src="https://img-blog.csdnimg.cn/1c84a48c41e94a228bfbac654801eb56.png"><br>点击“更新子组件props”后：<br><img src="https://img-blog.csdnimg.cn/d9b73c3667b9415faffbe0df833139f2.png"></li>
</ul>
<h1 id="组件的卸载："><a href="#组件的卸载：" class="headerlink" title="组件的卸载："></a>组件的卸载：</h1><p>生命周期的最后一个过程为组件卸载期，也称为组件销毁期。该过程主要涉及一个 方法，即componentWillUnmount，当组件从DOM树删除的时候调用该方法。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//组件卸载</span><br><span class="line">class HelloWorldFather extends React.Component{</span><br><span class="line">    constructor(props) {</span><br><span class="line">        super(props);</span><br><span class="line">        this.updateChildProps=this.updateChildProps.bind(this);</span><br><span class="line">        this.state={  //初始化父组件</span><br><span class="line">            name:"React"</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    updateChildProps(){  //更新父组件state</span><br><span class="line">        this.setState({</span><br><span class="line">            name:"Vue"</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">    render() {</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;HelloWorld name={this.state.name} /&gt;  {/*父组件的state传递给子组件*/}</span><br><span class="line">                &lt;button onClick={this.updateChildProps}&gt;更新子组件props&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">class HelloWorld extends React.Component{</span><br><span class="line">    constructor(props) {</span><br><span class="line">        super(props);</span><br><span class="line">        console.log("1,构造函数");</span><br><span class="line">        console.log("2,设置状态机")</span><br><span class="line">    }</span><br><span class="line">    UNSAFE_componentWillMount() {</span><br><span class="line">        console.log("3,完成首次渲染前调用");</span><br><span class="line">    }</span><br><span class="line">    UNSAFE_componentWillReceiveProps(nextProps, nextContext) {</span><br><span class="line">        console.log("6,父组件更新子组件时调用该方法");</span><br><span class="line">    }</span><br><span class="line">    shouldComponentUpdate(nextProps, nextState, nextContext) {</span><br><span class="line">        console.log("7,决定组件props或者state的改变是否需要重新进行渲染");</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    UNSAFE_componentWillUpdate(nextProps, nextState, nextContext) {</span><br><span class="line">        console.log("8,当接收到新的props或state时，调用该方法");</span><br><span class="line">    }</span><br><span class="line">    delComponent(){  //添加卸载方法</span><br><span class="line">        ReactDOM.unmountComponentAtNode(document.getElementById("root"));</span><br><span class="line">    }</span><br><span class="line">    render() {</span><br><span class="line">        console.log("4,组件进行渲染");</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;{this.props.name}&lt;/div&gt;</span><br><span class="line">                &lt;button onClick={this.delComponent}&gt;卸载组件&lt;/button&gt;  {/*声明卸载按钮*/}</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">    componentDidMount() {</span><br><span class="line">        console.log("5,componentDidMount render后的操作");</span><br><span class="line">    }</span><br><span class="line">    componentDidUpdate(prevProps, prevState, snapshot) {</span><br><span class="line">        console.log("9,组件被重新选然后调用该方法");</span><br><span class="line">    }</span><br><span class="line">    componentWillUnmount() {  //组件卸载后执行</span><br><span class="line">        console.log("10,组件已被卸载");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">ReactDOM.render(&lt;HelloWorldFather /&gt;,document.getElementById("root"));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/3fc8a13384eb4a1eb5b6df0e6dd72c10.png" alt="**加粗样式**"><br>点击卸载按钮后：<br><img src="https://img-blog.csdnimg.cn/2bd64f70a8e0438bb1f9e01ccb89e5e1.png"></p>
<h1 id="总览组件生命周期："><a href="#总览组件生命周期：" class="headerlink" title="总览组件生命周期："></a>总览组件生命周期：</h1><p><img src="https://img-blog.csdnimg.cn/7cd812539c5e4f6083bec0e3150d5dc6.png#pic_center"></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习日记</title>
    <url>/2022/09/19/typescript-xue-xi-ri-ji/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://www.tslang.cn/docs/handbook/generics.html">TypeScript</a> 是微软开发的 JavaScript 的超集，TypeScript兼容JavaScript，可以载入JavaScript代码然后运行。TypeScript与JavaScript相比进步的地方 包括：加入注释，让编译器理解所支持的对象和函数，编译器会移除注释，不会增加开销；增加一个完整的类结构，使之更新是传统的面向对象语言</p>
<h1 id="为什么会有TypeScript？"><a href="#为什么会有TypeScript？" class="headerlink" title="为什么会有TypeScript？"></a>为什么会有TypeScript？</h1><p>JavaScript 只是一个脚本语言，并非设计用于开发大型 Web 应用，JavaScript 没有提供类和模块的概念，而 TypeScript 扩展了 JavaScript 实现了这些特性。TypeScript 主要特点包括：</p>
<ul>
<li>TypeScript 是微软推出的开源语言，使用 Apache 授权协议</li>
<li>TypeScript 是 JavaScript 的超集.</li>
<li>TypeScript 增加了可选类型、类和模块</li>
<li>TypeScript 可编译成可读的、标准的 JavaScript</li>
<li>TypeScript 支持开发大规模 JavaScript 应用</li>
<li>TypeScript 设计用于开发大型应用，并保证编译后的 JavaScript 代码兼容性</li>
<li>TypeScript 扩展了 JavaScript 的语法，因此已有的 JavaScript 代码可直接与 TypeScript 一起运行无需更改</li>
<li>TypeScript 文件扩展名是 ts，而 TypeScript 编译器会编译成 js 文件</li>
<li>TypeScript 语法与 JScript .NET 相同</li>
<li>TypeScript 易学易于理解</li>
</ul>
<h1 id="JavaScript-与-TypeScript-的区别"><a href="#JavaScript-与-TypeScript-的区别" class="headerlink" title="JavaScript 与 TypeScript 的区别"></a>JavaScript 与 TypeScript 的区别</h1><p>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</p>
<h1 id="TypeScript优势"><a href="#TypeScript优势" class="headerlink" title="TypeScript优势"></a>TypeScript优势</h1><p>解决痛点<br>TypeScript的设计解决了JavaScript的“痛点”：弱类型和没有命名空间；这导致程序很难模块化，不适合开发大型程序。</p>
<p>语法提示<br>编写程序时，编辑器将提供精准的语法提示，以帮助大家更方便地实践面向对象的编程。</p>
<p>容易上手<br>TypeScript的一个设计亮点，是它并没有抛弃JavaScript的语法另起炉灶，而是做成了JavaScript的超集，任何合法的JavaScript的语句在TypeScript下都是合法的，且沿用了JavaScript的使用习惯和惯例，可以说学习成本很低。</p>
<h1 id="一、TypeScript安装、编译"><a href="#一、TypeScript安装、编译" class="headerlink" title="一、TypeScript安装、编译"></a>一、TypeScript安装、编译</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></tbody></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cnpm install -g typescript </span><br></pre></td></tr></tbody></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yarm global add typescript</span><br></pre></td></tr></tbody></table></figure>
<p>查看版本：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></tbody></table></figure>
<p>运行：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">tsc helloworld.ts</span><br></pre></td></tr></tbody></table></figure>
<p>注意：如果电脑上没有安装过yarn,请记得先安装</p>
<h1 id="二、配置TS开发工具-Vscode自动编译-ts文件"><a href="#二、配置TS开发工具-Vscode自动编译-ts文件" class="headerlink" title="二、配置TS开发工具 Vscode自动编译 .ts文件"></a>二、配置TS开发工具 Vscode自动编译 .ts文件</h1><ol>
<li>在目录所在位置打开终端cmd<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></tbody></table></figure>
生成配置文件</li>
<li> 然后取消生成的 <code>tsconfig.json</code> 中的  “outDir”，改为如下：<br><img src="https://img-blog.csdnimg.cn/7dc0af0fd25c44eca7a2fac0da69a343.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
<li>点击终端，选择typescript.选择监视选项<br><img src="https://img-blog.csdnimg.cn/f818b0fee1794e97925f02dbaf391948.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
<li>可以开始正常敲代码</li>
</ol>
<h1 id="三、TypeScript数据类型及理解"><a href="#三、TypeScript数据类型及理解" class="headerlink" title="三、TypeScript数据类型及理解"></a>三、TypeScript数据类型及理解</h1><ol>
<li>布尔类型（boolean）</li>
<li>数字类型（number）</li>
<li>字符串类型（string）</li>
<li>数组类型（array）</li>
<li>元组类型（tuple）</li>
<li>枚举类型（enum）</li>
<li>任意类型（any）</li>
<li>null 和 undefined（是never 数据类型的子类型）</li>
<li>void 类型</li>
<li>never 类型：<br>a. 表示的是那些永不存在的值的类型，never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never 类型（除了never本身之外）。 即使 any也不可以赋值给never。<br>b. 是其他类型（包括 null 和 undefined）的子类型，代表从不会出现的值。<br>c. 返回never的函数必须存在无法达到的终点 </li>
</ol>
<h1 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h1><h2 id="函数声明法"><a href="#函数声明法" class="headerlink" title="函数声明法"></a>函数声明法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function run():string{</span><br><span class="line">  return 'run'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="匿名函数法"><a href="#匿名函数法" class="headerlink" title="匿名函数法"></a>匿名函数法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">let fun2=function():number{</span><br><span class="line">  return 2;</span><br><span class="line">}</span><br><span class="line">alert(fun2());</span><br><span class="line"></span><br><span class="line">let getInfo1=function (name:string,age:number):string {</span><br><span class="line">    return `${name}--${age}`</span><br><span class="line">}</span><br><span class="line">alert(getInfo1('zhangdan',3434))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="没有返回值"><a href="#没有返回值" class="headerlink" title="没有返回值"></a>没有返回值</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function getInfo3(name:string,age:number):void {</span><br><span class="line">    console.log(`${name}--${age}`) </span><br><span class="line">}</span><br><span class="line">getInfo3('lixiaolong',3434)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="方法传参—可选参数"><a href="#方法传参—可选参数" class="headerlink" title="方法传参—可选参数"></a>方法传参—可选参数</h2><p><strong>注意：可选参数必须放在必须参数的后面</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// es5中的实参和形参可以不一样，但是ts中必须一样，否则就需要配置可选参数</span><br><span class="line">function getInfo4(name?:string,age?:number):string {</span><br><span class="line">    return `${name}--${age}`</span><br><span class="line">}</span><br><span class="line">alert(getInfo4('3453'))</span><br><span class="line">alert(getInfo4('',34))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="方法传参—设置默认参数"><a href="#方法传参—设置默认参数" class="headerlink" title="方法传参—设置默认参数"></a>方法传参—设置默认参数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">用户可以不传递这个参数或传递的值是undefined</span><br><span class="line">注意：与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined值来获得默认值</span><br><span class="line">function getInfo5(name?:string,age:number=20):string {</span><br><span class="line">    return `${name}--${age}`</span><br><span class="line">}</span><br><span class="line">alert(getInfo5('3453453',))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剩余传参—即-es6-中的-…-语法"><a href="#剩余传参—即-es6-中的-…-语法" class="headerlink" title="剩余传参—即 es6 中的 … 语法"></a>剩余传参—即 es6 中的 … 语法</h2><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// Java中的重载是指两个或两个以上同名函数，但是他们的参数不一样，这时会出现函数重载的情况</span><br><span class="line">// ts为了兼容es5 es6,重载方法和Java有区别</span><br><span class="line"></span><br><span class="line">// 在es5中，如果出现同名函数，则下面的会替换上面的方法</span><br><span class="line">// function name(params:any):any {</span><br><span class="line"></span><br><span class="line">// }</span><br><span class="line">// function name(params:any,config:any) {</span><br><span class="line"></span><br><span class="line">// }</span><br><span class="line"></span><br><span class="line">// ts中</span><br><span class="line">function getInfo6(names:string):string;</span><br><span class="line">function getInfo6(age:number):string;</span><br><span class="line">function getInfo6(str:any):any{</span><br><span class="line">    if (typeof str==='string') {</span><br><span class="line">        return names</span><br><span class="line">    }else{</span><br><span class="line">        return str</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">alert(getInfo6(20))</span><br></pre></td></tr></tbody></table></figure>

<h2 id="箭头函数—和-es6-一样"><a href="#箭头函数—和-es6-一样" class="headerlink" title="箭头函数—和 es6 一样"></a>箭头函数—和 es6 一样</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; {</span><br><span class="line">    alert(3333)</span><br><span class="line">}, 1000);</span><br></pre></td></tr></tbody></table></figure>

<h1 id="五、类"><a href="#五、类" class="headerlink" title="五、类"></a>五、类</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 通过class创建类</span><br><span class="line">class Animal {</span><br><span class="line">    // 类的属性</span><br><span class="line">    name: string;</span><br><span class="line">    // 类的构造器</span><br><span class="line">    constructor(name: string) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line">    // 类的方法</span><br><span class="line">    sayHello():void{</span><br><span class="line">        alert("hello animal:"+this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">// 实例化类</span><br><span class="line">var tom = new Animal("tom");</span><br><span class="line">tom.sayHello();</span><br></pre></td></tr></tbody></table></figure>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 通过class创建类</span><br><span class="line">class Animal {</span><br><span class="line">    // 类的属性</span><br><span class="line">    name: string;</span><br><span class="line"></span><br><span class="line">    // 类的构造器</span><br><span class="line">    constructor(name: string) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 类的方法</span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello animal:" + this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 继承Animal</span><br><span class="line">class Cat extends Animal {</span><br><span class="line">    // 重写方法</span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello cat:" + this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Dog extends Animal {</span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello dog:" + this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Animal {</span><br><span class="line">    private name: string; // 这里把name修饰符改为private</span><br><span class="line"></span><br><span class="line">    constructor(name: string) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello animal:" + this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Cat extends Animal {</span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello cat:" + this.name); //这里会报错，因为无法引用父类private修饰的属性</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Dog extends Animal {</span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello dog:" + this.name); //这里会报错，因为无法引用父类private修饰的属性</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Get-Set访问器"><a href="#Get-Set访问器" class="headerlink" title="Get/Set访问器"></a>Get/Set访问器</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Animal {</span><br><span class="line">    private name: string;</span><br><span class="line"></span><br><span class="line">    get name(): string { //通过get和set解决子类不能引用父类private修饰的属性的问题</span><br><span class="line">        return this.name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    set name(name: string) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    constructor(name: string) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello animal:" + this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Cat extends Animal {</span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello cat:" + this.name); </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Dog extends Animal {</span><br><span class="line">    sayHello(): void {</span><br><span class="line">        alert("hello dog:" + this.name); </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Table {</span><br><span class="line">    static width: Number = 100;</span><br><span class="line">    static height: Number = 50</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var width: Number = Table.width;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="六、接口"><a href="#六、接口" class="headerlink" title="六、接口"></a>六、接口</h1><h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">interface Graphic {</span><br><span class="line">    width: Number;</span><br><span class="line">    height: Number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Square implements Graphic {</span><br><span class="line">    width: Number;</span><br><span class="line">    height: Number;</span><br><span class="line"></span><br><span class="line">    constructor() {</span><br><span class="line">        this.width = 100;</span><br><span class="line">        this.height = 100;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    constructor(width: Number, height: Number) {</span><br><span class="line">        this.height = height;</span><br><span class="line">        this.width = width;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">interface Graphic {</span><br><span class="line">    width: Number;</span><br><span class="line">    height: Number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface PenStroke {</span><br><span class="line">    penWidth: Number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface Square extends Graphic, PenStroke {</span><br><span class="line">    sideLength: number;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="七、泛型"><a href="#七、泛型" class="headerlink" title="七、泛型"></a>七、泛型</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。<br>通俗理解：泛型就是解决类、接口、方法的复用性以及对不特定数据类型的支持</p>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function getDate&lt;T&gt;(value: T): T {</span><br><span class="line">    console.log('3453453453');</span><br><span class="line">    return value;</span><br><span class="line">}</span><br><span class="line">getDate&lt;number&gt;(345345);   // 3453453453</span><br><span class="line">getDate&lt;string&gt;('String')  // 3453453453</span><br><span class="line"></span><br><span class="line">function getDate1&lt;T&gt;(value: T): any {</span><br><span class="line">    console.log(value);  // 345345</span><br><span class="line">    return value + '345345345';</span><br><span class="line">}</span><br><span class="line">alert(getDate1&lt;number&gt;(345345));   // 345345345345345</span><br></pre></td></tr></tbody></table></figure>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Minclass&lt;T&gt;{</span><br><span class="line">    public list: T[] = []</span><br><span class="line"></span><br><span class="line">    add(value: T) {</span><br><span class="line">        this.list.push(value)</span><br><span class="line">    }</span><br><span class="line">    min(): T {</span><br><span class="line">        let minest = this.list[0];</span><br><span class="line">        for (let i = 0; i &lt; this.list.length; i++) {</span><br><span class="line">            if (minest &gt; this.list[i]) {</span><br><span class="line">                minest = this.list[i]</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return minest</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let ert = new Minclass&lt;number&gt;()</span><br><span class="line">ert.add(34)</span><br><span class="line">ert.add(89)</span><br><span class="line">ert.add(56)</span><br><span class="line">ert.add(67)</span><br><span class="line">ert.add(23)</span><br><span class="line">ert.add(16)</span><br><span class="line">ert.add(79)</span><br><span class="line">alert(ert.min())</span><br><span class="line"></span><br><span class="line">let strs = new Minclass&lt;string&gt;()</span><br><span class="line">strs.add('bc')</span><br><span class="line">strs.add('dfgd')</span><br><span class="line">strs.add('erf')</span><br><span class="line">strs.add('zdf')</span><br><span class="line">strs.add('abcd')</span><br><span class="line">alert(strs.min())</span><br></pre></td></tr></tbody></table></figure>

<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">interface configFn {</span><br><span class="line">    &lt;T&gt;(confg: T): T</span><br><span class="line">}</span><br><span class="line">let getData: configFn = function &lt;T&gt;(value: T): T {</span><br><span class="line">    return value;</span><br><span class="line">}</span><br><span class="line">getData&lt;number&gt;(34)</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">interface config4&lt;T&gt; {</span><br><span class="line">    (config: T): T</span><br><span class="line">}</span><br><span class="line">function getData2&lt;T&gt;(value: T): T {</span><br><span class="line">    return value;</span><br><span class="line">}</span><br><span class="line">let test: config4&lt;string&gt; = getData2</span><br><span class="line">test('sdfsdf')</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <tags>
        <tag>前端</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE的扩展运算符</title>
    <url>/2022/09/19/vue-de-kuo-zhan-yun-suan-fu/</url>
    <content><![CDATA[<p>含义：<br>扩展运算符（ spread ）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br>操作数组：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">//里面放自己定义的方法</span></span><br><span class="line">    methods: {</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 把数组中的元素孤立起来</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick</span>() {</span><br><span class="line">        let iArray = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">        console.<span class="built_in">log</span>(...iArray);</span><br><span class="line">        <span class="comment">// 打印结果  1 2 3</span></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 在数组中添加元素</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick3</span>() {</span><br><span class="line">        let iArray = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">        console.<span class="built_in">log</span>([<span class="string">'0'</span>, ...iArray, <span class="string">'4'</span>]);</span><br><span class="line">        <span class="comment">// 打印结果  ["0", "1", "2", "3", "4"]</span></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 在数组中删除元素（取出一个元素）</span></span><br><span class="line"><span class="comment">       * 与结构赋值的结合</span></span><br><span class="line"><span class="comment">       * 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick8</span>() {</span><br><span class="line">        <span class="type">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">        console.<span class="built_in">log</span>(first);</span><br><span class="line">        <span class="comment">// 打印结果 1</span></span><br><span class="line">        console.<span class="built_in">log</span>([...rest]);</span><br><span class="line">        <span class="comment">// 打印结果 [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> [one, ...last] = [<span class="string">"foo"</span>];</span><br><span class="line">        console.<span class="built_in">log</span>(one);</span><br><span class="line">        <span class="comment">//打印结果 foo</span></span><br><span class="line">        console.<span class="built_in">log</span>([...last]);</span><br><span class="line">        <span class="comment">//打印结果 []</span></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 数组的合并</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick6</span>() {</span><br><span class="line">        <span class="comment">// ES6 的写法</span></span><br><span class="line">        var arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">        var arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">        arr1.<span class="built_in">push</span>(...arr2);</span><br><span class="line">        console.<span class="built_in">log</span>(arr1);</span><br><span class="line">        <span class="comment">//  打印结果 [0, 1, 2, 3, 4, 5]</span></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 数组的合并（推荐使用）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick7</span>() {</span><br><span class="line">        var arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">        var arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">        console.<span class="built_in">log</span>([...arr1, ...arr2]);</span><br><span class="line">        <span class="comment">//  打印结果 [0, 1, 2, 3, 4, 5]</span></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 将字符串转成数组</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick9</span>() {</span><br><span class="line">        let iString = <span class="string">'woshizhongguoren'</span>;</span><br><span class="line">        console.<span class="built_in">log</span>([...iString]);</span><br><span class="line">        <span class="comment">//  打印结果 ["w", "o", "s", "h", "i", "z", "h", "o", "n", "g", "g", "u", "o", "r", "e", "n"]</span></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Map 和 Set 结构， Generator 函数</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick10</span>() {</span><br><span class="line">        let map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">          [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">          [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">          [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">        ]);</span><br><span class="line">        let arr = [...map.<span class="built_in">keys</span>()];</span><br><span class="line">        console.<span class="built_in">log</span>(arr);</span><br><span class="line">        <span class="comment">//  打印结果 [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 当做参数传递</span></span><br><span class="line"><span class="comment">       * 和直接传数组的区别</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick4</span>() {</span><br><span class="line">        let iArray = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">        <span class="comment">//注意传的时候，就要三个点</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">hanshu</span>(...iArray);</span><br><span class="line">      },</span><br><span class="line">      <span class="built_in">hanshu</span>(...iArray) {</span><br><span class="line">        let ooo = <span class="number">1</span>;</span><br><span class="line">        console.<span class="built_in">log</span>(...iArray);</span><br><span class="line">        <span class="comment">//  打印结果 1 2 3</span></span><br><span class="line">      },</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 求出最大值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick5</span>() {</span><br><span class="line">        let iArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">44</span>, <span class="number">66</span>, <span class="number">21</span>, <span class="number">85</span>, <span class="number">77</span>];</span><br><span class="line">        let ooo = Math.<span class="built_in">max</span>(...iArray);</span><br><span class="line">        console.<span class="built_in">log</span>(ooo);</span><br><span class="line">        <span class="comment">//  打印结果 99</span></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 如果对没有iterator接口的对象，使用扩展运算符，将会报错。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">iClick11</span>() {</span><br><span class="line">        let obj = {</span><br><span class="line">          name: <span class="string">'zhh'</span>,</span><br><span class="line">          age: <span class="string">'20'</span></span><br><span class="line">        }</span><br><span class="line">        console.<span class="built_in">log</span>([...obj]);</span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">操作对象：</span><br><span class="line"> methods: {</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 添加一个属性</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">method3</span>() {</span><br><span class="line">        let a = {age: <span class="number">18</span>, id: <span class="number">10</span>};</span><br><span class="line">        <span class="comment">// 把 name 属性，放到对象中</span></span><br><span class="line">        let c = {name: <span class="string">'zhh'</span>, ...a};</span><br><span class="line">        console.<span class="built_in">log</span>(c);</span><br><span class="line">        <span class="comment">//  打印结果  {name: "zhh", age: 18, id: 10}</span></span><br><span class="line"></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 修改一个属性</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">method2</span>() {</span><br><span class="line">        let a = {name: <span class="string">'zhh'</span>, age: <span class="number">18</span>, id: <span class="number">10</span>};</span><br><span class="line">        <span class="comment">//先拿到a, 后面的name:zhh1,把 a 中name 的值替换掉了</span></span><br><span class="line">        let c = {...a, name: <span class="string">'zhh1'</span>};</span><br><span class="line">        console.<span class="built_in">log</span>(c);</span><br><span class="line">        <span class="comment">// 打印结果  {name: "zhh1", age: 18, id: 10}</span></span><br><span class="line"></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 删除一个属性（拿出属性或者对象）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">method1</span>() {</span><br><span class="line">        let a = {name: <span class="string">'zhh'</span>, age: <span class="number">18</span>, id: <span class="number">10</span>};</span><br><span class="line">        let {name, ...c} = a;</span><br><span class="line">        console.<span class="built_in">log</span>(name, c);</span><br><span class="line">        <span class="comment">//  打印结果 zhh {age: 18, id: 10}</span></span><br><span class="line">      },</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <tags>
        <tag>vue.js</tag>
        <tag>javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vant Uploader 图片上传，根据后端url回显问题</title>
    <url>/2022/09/19/vant-uploader-tu-pian-shang-chuan-gen-ju-hou-duan-url-hui-xian-wen-ti/</url>
    <content><![CDATA[<p>今天在开发中，用到van-uploader上传。在修改用户信息的时候，需要用到图片回显。</p>
<p>当图片信息，后端返回的是一个url地址。如何在组件中进行回显呢。</p>
<p>在官方文档中有提到，可以有自定义上传样式。那我们是不是可以把button换成img，src就用后端返回的url，就可以进行回显了呢。</p>
<p><img src="https://img-blog.csdnimg.cn/4f0089fee79b468b9e1dd12c9ee8cd46.png"><br>把 van-button换成van-image</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;van-uploader</span><br><span class="line">    :max-count="1"</span><br><span class="line">    :after-read="handleUpload"</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;van-image  width="60" height="60" </span><br><span class="line">             :src="formTenant.merchantHead?formTenant.merchantHead:require('@/assets/morentu.png')" /&gt;</span><br><span class="line">&lt;/van-uploader&gt;</span><br></pre></td></tr></tbody></table></figure>
<p> formTenant.merchantHead就是后端返回的url，以上用了三元表达式，如果后端有返回值，就渲染返回值，如果没有则渲染默认图片。</p>
<p>以上就是Vant Uploader 图片回显，特此记录。</p>
]]></content>
      <tags>
        <tag>vue.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 清除Form 表单二次弹出表单时上次的提示信息</title>
    <url>/2022/09/19/vue-qing-chu-form-biao-dan-er-ci-dan-chu-biao-dan-shi-shang-ci-de-ti-shi-xin-xi/</url>
    <content><![CDATA[<p>二次打开表单，验证提示信息还在，如何解决呢？<br><img src="https://img-blog.csdnimg.cn/912b4eb3c3954c43a43d49cdcc2d8ba6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_14,color_FFFFFF,t_70,g_se,x_16"><br>话不多说，直接上代码<br>在弹出表单方法内加入下面代码即可<br><strong>①清除表单内容和清除表单验证消息</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">this.$nextTick(()=&gt;{</span><br><span class="line">	this.$refs.form.resetFields();</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p><strong>②只清除表单验证消息、不清楚表单内容</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">this.$nextTick(()=&gt;{</span><br><span class="line">  this.$refs['form'].clearValidate() // 只清除清除验证</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>vue.js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中使用el-data-picker报错 Avoid mutating a prop directly since the value will be overwrite</title>
    <url>/2022/09/19/vue-zhong-shi-yong-el-data-picker-bao-cuo-avoid-mutating-a-prop-directly-since-the-value-will-be-overwrite/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/0d3194fbdcfb40b9979505b291540af0.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>锁定组件，发现是 el-date-picker 组件抛出的警告。通过在 github 上搜索，最终找到了答案<br>问题出在了这个 PR #21806 增加了 props placement 用来适应位置，但是之前的代码 created 时有给 placement 赋值。<br>this.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;<br>说白了之前 placement 是 data 的对象，现在变成 props 了，然后修改就报错了</p>
</blockquote>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote>
<p>想要解决这个问题，可以修改版本到 2.15.8</p>
<blockquote>
<p>npm uninstall element-ui<br>npm install <a href="mailto:element-ui@2.15.8">element-ui@2.15.8</a> -s<br><img src="https://img-blog.csdnimg.cn/aab330da73bb4df2bd068434372343c1.png" alt="在这里插入图片描述"><br><strong>注意：这里不要【‘^’】,否则还会报错</strong></p>
</blockquote>
</blockquote>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实现Word文档在线预览功能（内网、外网）！！！</title>
    <url>/2022/09/19/vue-shi-xian-word-wen-dang-zai-xian-yu-lan-gong-neng-nei-wang-wai-wang/</url>
    <content><![CDATA[<h2 id="内网实现方法："><a href="#内网实现方法：" class="headerlink" title="内网实现方法："></a><strong>内网实现方法：</strong></h2><p>需要下载两个插件，一定要注意！！</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm i docx-preview@0.1.4</span><br><span class="line"></span><br><span class="line">npm i jszip</span><br></pre></td></tr></tbody></table></figure>

<p>正文中引入</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div ref="preview"  id="preview" &gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let docx = require("docx-preview");</span><br><span class="line">	window.JSZip = require("jszip");</span><br><span class="line">	</span><br><span class="line">    // 查看文档按钮</span><br><span class="line">    handleFile(row) {</span><br><span class="line">		this.getDocx() .then((response) =&gt; {</span><br><span class="line">			console.log(response);  // response为流文件</span><br><span class="line">			docx.renderAsync(response.data, this.$refs.preview);</span><br><span class="line">			// 渲染到页面（着重注意 this.$refs.preview要和&lt;div ref="preview"&gt;&lt;/div&gt;保持一致）</span><br><span class="line">		})</span><br><span class="line">		.catch(function (error) {});</span><br><span class="line">	}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="外网实现方法："><a href="#外网实现方法：" class="headerlink" title="外网实现方法："></a><strong>外网实现方法：</strong></h2><p>可以用下面这种方式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;iframe</span><br><span class="line">	:src="`https://view.officeapps.live.com/op/view.aspx?src=${downloadUrl}`"</span><br><span class="line">	width="100%"</span><br><span class="line">	:height="height"</span><br><span class="line">	frameborder="1"</span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>有时候使用这种方式会遇到下面提示：<br><img src="https://img-blog.csdnimg.cn/6a435d1088624d77b590b4b5e4d9e2a4.png#pic_center"></p>
<p>不要因此就直接放弃这种方式，好好找找原因。我这边遇到该情况的原因是因为本地DNS不解析该链接，后将DNS改为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">dns: 101.198.198.198</span><br><span class="line">     114.114.114.114</span><br></pre></td></tr></tbody></table></figure>
<p>完美的解决了该问题。<br>好了，可以轻松实现文档预览啦</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目中使用@代替src——并在VScode中开启@路径自动提示</title>
    <url>/2022/09/19/vue-xiang-mu-zhong-shi-yong-dai-ti-src-bing-zai-vscode-zhong-kai-qi-lu-jing-zi-dong-ti-shi/</url>
    <content><![CDATA[<p><code>配置引用路径（以“@”引用为项目的src目录为例）可拆分为如下两步操作</code><br> <code> - 配置webpack打包时将“@”解析为项目的src目录</code><br> <code> - 配置vsCode在路径中输入“@”时的路径提示</code></p>
<p><code>一般的 “路径别名” ：</code><br><code>+ @ ——src</code><br><code>+ components —— src/components</code></p>
<p>一共分为3步。</p>
<h3 id="第一步：安装path模块"><a href="#第一步：安装path模块" class="headerlink" title="第一步：安装path模块"></a>第一步：安装path模块</h3><p>可以先看看自己的<code>node_modules</code>文件里面能不能找到path模块。<br>如果没有，那就安装，终端运行：<br><code>npm install path --save</code></p>
<h3 id="第二步：设置路径别名"><a href="#第二步：设置路径别名" class="headerlink" title="第二步：设置路径别名"></a>第二步：设置路径别名</h3><p>我的项目使用的是 vue-cli 脚手架 搭建的。<br>首先在和 <code>src</code>并齐的<code>vue.config.js</code>[没有就新建]中，使用<code>path</code>模块，设置一些路径的别名。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">const path = require("path");</span><br><span class="line">function resolve(dir) {</span><br><span class="line">  return path.join(__dirname, dir);</span><br><span class="line">} </span><br><span class="line">module.exports = {</span><br><span class="line">  chainWebpack: config =&gt; {</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set("@", resolve("src"))</span><br><span class="line">      .set("assets", resolve("src/assets"))</span><br><span class="line">      .set("components", resolve("src/components"))</span><br><span class="line">      .set("base", resolve("baseConfig"))</span><br><span class="line">      .set("public", resolve("public"));</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="第三步：VScode-设置路径自动补全"><a href="#第三步：VScode-设置路径自动补全" class="headerlink" title="第三步：VScode 设置路径自动补全"></a>第三步：<a href="https://so.csdn.net/so/search?q=VScode&amp;spm=1001.2101.3001.7020">VScode</a> 设置路径自动补全</h3><p>在我们进行上述两个步骤之后，我们的@/…是可以正常使用了，但是！我们在编辑器输入@/以后，编辑器不会自动给我们提示。</p>
<p>那这样的话，我们还不如像以前那样的用./ ../这样式的路径，所以，这个时候，配置编辑器自动提示就十分必要了！</p>
<p>接下来，我们可以进行下面的操作：</p>
<ol>
<li>打开VScode的设置</li>
<li>点击下面的按钮，打开<code>setting.json</code><br><img src="%5B90bf54e322794829842bd7af7e18ee29.png%5D(https://img-blog.csdnimg.cn/90bf54e322794829842bd7af7e18ee29.png)"></li>
<li>第二步也可以通过使用快捷键 <code>ctrl + shift + p</code>召唤搜索框，·搜索<code>setting.json</code></li>
<li>添加如下代码：<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">   "path-intellisense.mappings": {</span><br><span class="line">   		"@": "${workspaceRoot}/src"</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<blockquote>
<p>以上的所有配置好了，代码确定没有错误之后，我们就可以正常使用@/…的方式来写路径了。不要忘记重启VScode哦！！！！</p>
</blockquote>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript 原型、原型链、继承</title>
    <url>/2022/09/19/javascript-yuan-xing-yuan-xing-lian-ji-cheng/</url>
    <content><![CDATA[<h1 id="一、prototype"><a href="#一、prototype" class="headerlink" title="一、prototype"></a>一、prototype</h1><p>在JavaScript中，每一个函数都有一个prototype属性，这个属性指向函数的原型对象。<br>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function Person(age){</span><br><span class="line">  this.age=age;</span><br><span class="line">}</span><br><span class="line">Person.prototype.name='张三';</span><br><span class="line"></span><br><span class="line">val per1= new Person();</span><br><span class="line">val per2= new Person();</span><br><span class="line"></span><br><span class="line">console.log(per1.name); //张三</span><br><span class="line">console.log(per2.name); //张三</span><br></pre></td></tr></tbody></table></figure>
<p>上述例子中，函数Person的prototype指向了一个对象，而这个对象正是调用构造函数时创建的原型实例，即per1和 per2的原型。</p>
<p>原型的概念：每一个JavaScript对象（除null外）在创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型。每一个对象都会从原型中”继承”属性。</p>
<p>用一张图来表示构造函数与实例原型之间的关系：<br><img src="https://img-blog.csdnimg.cn/42579455dc1d4a6d95f43c2222ad7393.png" alt=" "></p>
<h1 id="二、proto"><a href="#二、proto" class="headerlink" title="二、proto"></a>二、<em>proto</em></h1><p>这是每个对象（除null外）都会有的属性。这个属性指向该对象的原型。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function Person() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">val per=new Person();</span><br><span class="line">console.log(per._proto_ === Person.prototype); //true</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/d63129ac691e455b9c2776dc1f463c49.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h1 id="三、constructor"><a href="#三、constructor" class="headerlink" title="三、constructor"></a>三、constructor</h1><p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function Person() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">console.log(Person===Person.prototype.constructor)  //true</span><br></pre></td></tr></tbody></table></figure>
<p>即：<br><img src="https://img-blog.csdnimg.cn/68d6c22595e645269f2a4cce95ccde12.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function Person() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></tbody></table></figure>
<p><strong>补充：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function Person() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line">person.constructor=Person;</span><br></pre></td></tr></tbody></table></figure>
<p>解释：当获取person.constructor时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">person.constructor=Person.prototype.constructor;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="四：实例与原型"><a href="#四：实例与原型" class="headerlink" title="四：实例与原型"></a>四：实例与原型</h1><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function Person() {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Person.prototype.name = 'Kevin';</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">person.name = 'Daisy';</span><br><span class="line">console.log(person.name) // Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。<br>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h1 id="五、原型的原型"><a href="#五、原型的原型" class="headerlink" title="五、原型的原型"></a>五、原型的原型</h1><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.name = 'Kevin'</span><br><span class="line">console.log(obj.name) // Kevin</span><br></pre></td></tr></tbody></table></figure>
<p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：<br><img src="https://img-blog.csdnimg.cn/b962c76a68984903b6e87fc4572ee115.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h1 id="六、原型链"><a href="#六、原型链" class="headerlink" title="六、原型链"></a>六、原型链</h1><p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p>
<p>其实简单来说，就是上述四-五的过程。<br>继上述五中所说，那 Object.prototype 的原型呢？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null) // true</span><br></pre></td></tr></tbody></table></figure>
<p>引用阮一峰老师的 《undefined与null的区别》 就是：<br>null 表示“没有对象”，即该处不应该有值。<br>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。<br>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图也可以更新为：<br><img src="https://img-blog.csdnimg.cn/701fac7dbea84c6880515236c4af4c64.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16"><br>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
<p><strong>原型链继承方案有以下缺点：</strong><br>● 1、多个实例对引用类型的操作会被篡改<br>● 2、子类型的原型上的 constructor 属性被重写了<br>● 3、给子类型原型添加属性和方法必须在替换原型之后<br>● 4、创建子类型实例时无法向父类型的构造函数传参</p>
<p>问题1：<br>原型链继承方案中，原型实际上会变成另一个类型的实例，如下代码，<code>Cat.prototype</code> 变成了 <code>Animal </code>的一个实例，所以 <code>Animal</code> 的实例属性 names 就变成了 <code>Cat.prototype</code> 的属性。<br>而原型属性上的引用类型值会被所有实例共享，所以多个实例对引用类型的操作会被篡改。如下代码，改变了 <code>instance1.names</code> 后影响了 <code>instance2</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">function Animal(){</span><br><span class="line">  this.names = ["cat", "dog"];</span><br><span class="line">}</span><br><span class="line">function Cat(){}</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">var instance1 = new Cat();</span><br><span class="line">instance1.names.push("tiger");</span><br><span class="line">console.log(instance1.names); // ["cat", "dog", "tiger"]</span><br><span class="line"></span><br><span class="line">var instance2 = new Cat(); </span><br><span class="line">console.log(instance2.names); // ["cat", "dog", "tiger"]</span><br></pre></td></tr></tbody></table></figure>
<p>问题2：<br>子类型原型上的 <code>constructor </code>属性被重写了，执行<code> Cat.prototype = new Animal()</code> 后原型被覆盖，<code>Cat.prototype</code> 上丢失了 <code>constructor</code> 属性， <code>Cat.prototype</code> 指向了 <code>Animal.prototype</code>，而 <code>Animal.prototype.constructor</code> 指向了<code> Animal</code>，所以 <code>Cat.prototype.constructor</code> 指向了 <code>Animal</code>。<br><img src="https://img-blog.csdnimg.cn/b9cbc47af0c743499dc6980ddb37580e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_9,color_FFFFFF,t_70,g_se,x_16"><br>解决办法就是重写 Cat.prototype.constructor 属性，指向自己的构造函数 Cat。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">function Animal() {</span><br><span class="line">    this.value = 'animal';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Animal.prototype.run = function() {</span><br><span class="line">    return this.value + ' is runing';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function Cat() {}</span><br><span class="line">Cat.prototype = new Animal(); </span><br><span class="line"></span><br><span class="line">// 新增，重写 Cat.prototype 的 constructor 属性，指向自己的构造函数 Cat</span><br><span class="line">Cat.prototype.constructor = Cat; </span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/58bb808425c74db6b9c9a13ae5a83dae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16"><br>问题3：<br>给子类型原型添加属性和方法必须在替换原型之后，原因在第二点已经解释过了，因为子类型的原型会被覆盖。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">function Animal() {</span><br><span class="line">    this.value = 'animal';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Animal.prototype.run = function() {</span><br><span class="line">    return this.value + ' is runing';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function Cat() {}</span><br><span class="line">Cat.prototype = new Animal(); </span><br><span class="line">Cat.prototype.constructor = Cat; </span><br><span class="line"></span><br><span class="line">// 新增</span><br><span class="line">Cat.prototype.getValue = function() {</span><br><span class="line">  return this.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance = new Cat();</span><br><span class="line">instance.value = 'cat'; </span><br><span class="line">console.log(instance.getValue()); // cat</span><br></pre></td></tr></tbody></table></figure>

<h1 id="七、属性遮蔽"><a href="#七、属性遮蔽" class="headerlink" title="七、属性遮蔽"></a>七、属性遮蔽</h1><p>改造上面的代码，在 <code>Cat.prototype</code> 上添加<code>run</code> 方法，但是 <code>Animal.prototype</code> 上也有一个 <code>run</code> 方法，不过它不会被访问到，这种情况称为属性遮蔽 (property shadowing)。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">function Animal() {</span><br><span class="line">    this.value = 'animal';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Animal.prototype.run = function() {</span><br><span class="line">    return this.value + ' is runing';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function Cat() {}</span><br><span class="line">Cat.prototype = new Animal(); </span><br><span class="line">Cat.prototype.constructor = Cat; </span><br><span class="line"></span><br><span class="line">// 新增</span><br><span class="line">Cat.prototype.run = function() {</span><br><span class="line">  return 'cat cat cat';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var instance = new Cat();</span><br><span class="line">instance.value = 'cat'; </span><br><span class="line">console.log(instance.run()); // cat cat cat</span><br></pre></td></tr></tbody></table></figure>
<p>那如何访问被遮蔽的属性呢？通过<code> __proto__</code> 调用原型链上的属性即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">conlole.log(instance.__proto__.__proto__.run()); // undefined is runing</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e810ed71d3b6417092fa50b3fc37562b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_13,color_FFFFFF,t_70,g_se,x_16"></p>
<h1 id="八、JS常用八种继承方式"><a href="#八、JS常用八种继承方式" class="headerlink" title="八、JS常用八种继承方式"></a>八、JS常用八种继承方式</h1><ol>
<li>原型链继承</li>
<li>借用构造函数继承</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
<li>混入方式继承多个对象</li>
<li>ES6类继承extends</li>
</ol>
<p> 具体有关分析请看下章。如果写得不够清晰或者不够全面还望理解哈！随着不断学习，会将文章补充的更好哒。</p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>npm run eject 报错This git repository has untracked files or uncommitted changes解决方案</title>
    <url>/2022/09/19/npm-run-eject-bao-cuo-this-git-repository-has-untracked-files-or-uncommitted-changes-jie-jue-fang-an/</url>
    <content><![CDATA[<p>在创建 React 项目之后，使用 npm run eject 命令会报错：This git repository has untracked files or uncommitted changes。这个的原因是因为初始化项目之后，该项目并没有本地 git 仓库，而此项目目录下又有 .gitignore 文件，所以此时会向上级寻找未提交的项目。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.初始化仓库</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></tbody></table></figure>
<p>2.添加并提交</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m '初始化项目'</span><br></pre></td></tr></tbody></table></figure>
<p>3.重新执行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>git</tag>
        <tag>npm</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 整合 mock.js（2022）</title>
    <url>/2022/09/19/vue3-zheng-he-mock-js-2022/</url>
    <content><![CDATA[<h2 id="第一步：安装"><a href="#第一步：安装" class="headerlink" title="第一步：安装"></a>第一步：安装</h2><h3 id="1-安装mockjs"><a href="#1-安装mockjs" class="headerlink" title="1. 安装mockjs"></a>1. 安装mockjs</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 将mockjs 安装在 devDependencies 中，只能在生产环境中起作用</span><br><span class="line">npm install mockjs -D</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-安装axios"><a href="#2-安装axios" class="headerlink" title="2. 安装axios"></a>2. 安装axios</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm i axios --save</span><br></pre></td></tr></tbody></table></figure>
<h2 id="第二步：编写请求文件user-ts"><a href="#第二步：编写请求文件user-ts" class="headerlink" title="第二步：编写请求文件user.ts"></a>第二步：编写请求文件user.ts</h2><h3 id="1-在src下面新建mock文件夹，然后在其中创建-index-ts-文件"><a href="#1-在src下面新建mock文件夹，然后在其中创建-index-ts-文件" class="headerlink" title="1.在src下面新建mock文件夹，然后在其中创建 index.ts 文件"></a>1.在src下面新建mock文件夹，然后在其中创建 <code>index.ts</code> 文件</h3><p>将所需的mock请求文件<code>home.ts</code>引入，并在该页面做相关mock配置，具体配置可查看官网。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 首先引入Mock</span><br><span class="line">const Mock = require('mockjs')</span><br><span class="line"></span><br><span class="line">// 引入所有的mock文件</span><br><span class="line">require('@/mock/api/home')</span><br><span class="line"></span><br><span class="line">// 设置拦截ajax请求的相应时间</span><br><span class="line">// Mock.setup({</span><br><span class="line">//     timeout: '200-600'</span><br><span class="line">// });</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-在mock文件夹下建立api文件夹，mock请求文件在该页面写入。"><a href="#2-在mock文件夹下建立api文件夹，mock请求文件在该页面写入。" class="headerlink" title="2. 在mock文件夹下建立api文件夹，mock请求文件在该页面写入。"></a>2. 在mock文件夹下建立api文件夹，mock请求文件在该页面写入。</h3><p>以下示例文件为<code>home.ts</code> 文件,包含增删改查操作，供大家参考。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">const Mocks = require("mockjs")</span><br><span class="line"></span><br><span class="line">const tipList = [</span><br><span class="line">    {</span><br><span class="line">        id: 0,</span><br><span class="line">        title: "冬",</span><br><span class="line">        content: "农历正月初五,</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        id: 1,</span><br><span class="line">        title: "每日计划",</span><br><span class="line">        content: "每日计划"</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        id: 2,</span><br><span class="line">        title: "明日安排",</span><br><span class="line">        content: "明日安排"</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        id: 3,</span><br><span class="line">        title: "会议总结",</span><br><span class="line">        content: "会议议题。出现了什么问题;信息分享"</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        id: 4,</span><br><span class="line">        title: "电影清单",</span><br><span class="line">        content: "电影"</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        id: 5,</span><br><span class="line">        title: "歌曲收藏",</span><br><span class="line">        content: "无感"</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        id: 6,</span><br><span class="line">        title: "路程",</span><br><span class="line">        content: "路程"</span><br><span class="line">    }, {</span><br><span class="line">        id: 7,</span><br><span class="line">        title: "联系电话",</span><br><span class="line">        content: "2343242342342343"</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        id: 8,</span><br><span class="line">        title: "邮箱",</span><br><span class="line">        content: "24534534534@qq.com"</span><br><span class="line">    },</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 获取所有便签</span><br><span class="line">const article = Mocks.mock("/home/article", () =&gt; {</span><br><span class="line">    return tipList</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 搜索便签</span><br><span class="line">const selectA = Mocks.mock("/home/selectArticle", (ops: any) =&gt; {</span><br><span class="line">    const obj = eval("(" + ops.body + ")")</span><br><span class="line">    const list: any[] = []</span><br><span class="line">    tipList.filter((item) =&gt; {</span><br><span class="line">        if (item.title.indexOf(obj.val) &gt;= 0) {</span><br><span class="line">            list.push(item)</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    return list;</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 获取便签详情s</span><br><span class="line">const details = Mocks.mock("/getDetail", (ops: any) =&gt; {</span><br><span class="line">    const obj = eval("(" + ops.body + ")")</span><br><span class="line">    for (let i = 0; i &lt; tipList.length; i++) {</span><br><span class="line">        if (tipList[i].id == obj.id) {</span><br><span class="line">            return tipList[i]</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line">// 修改便签内容</span><br><span class="line">const fex = Mocks.mock("/api/updateTip", (ops: any) =&gt; {</span><br><span class="line">    const obj = eval("(" + ops.body + ")")</span><br><span class="line">    tipList[obj.data.id].title = obj.data.title</span><br><span class="line">    tipList[obj.data.id].content = obj.data.content</span><br><span class="line">})</span><br><span class="line">// 删除便签</span><br><span class="line">const del = Mocks.mock("/api/deleteTip", (ops: any) =&gt; {</span><br><span class="line">    const obj = eval("(" + ops.body + ")")</span><br><span class="line">    for (let i = 0; i &lt; tipList.length; i++) {</span><br><span class="line">        if (tipList[i].id == obj.id) {</span><br><span class="line">            tipList.splice(i, 1)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line">// 新增便签</span><br><span class="line">const add = Mocks.mock("/api/addTip", (ops: any) =&gt; {</span><br><span class="line">    const obj = eval("(" + ops.body + ")")</span><br><span class="line">    obj.data.id=tipList.length</span><br><span class="line">    tipList.push(obj.data)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 返回模拟的数据及接口：</span><br><span class="line">module.exports = (router) =&gt; {</span><br><span class="line">    return [</span><br><span class="line">        router.get('/api/article', article),</span><br><span class="line">        router.get('/home/selectArticle', selectA),</span><br><span class="line">        router.get('/api/getDetail', details),</span><br><span class="line">        router.post('/api/updateTip', fex),</span><br><span class="line">        router.delete('/api/deleteTip', del),</span><br><span class="line">        router.put('/api/addTip', add),</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-写接口文件"><a href="#3-写接口文件" class="headerlink" title="3.写接口文件"></a>3.写接口文件</h3><p>在src 文件夹下新建 <code>api文件夹</code> ，在文件夹下新建<code>home.ts 文件</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import axios from 'axios'</span><br><span class="line"></span><br><span class="line">export function getArticles() {</span><br><span class="line">    return axios.get('/home/article')  // mockjs返回的接口</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 搜索便签</span><br><span class="line">export function selectA(val) {</span><br><span class="line">    return axios.get('/home/selectArticle', { data: val })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 详情</span><br><span class="line">export function getDetail(id) {</span><br><span class="line">    return axios.get('/getDetail', { data: id })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 修改便签</span><br><span class="line">export function fex(data) {</span><br><span class="line">    return axios.post('/api/updateTip', { data: data })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 删除便签</span><br><span class="line">export function del(id) {</span><br><span class="line">    return axios.delete('/api/deleteTip', { data: id })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 新增便签</span><br><span class="line">export function add(data) {</span><br><span class="line">    return axios.put('/api/addTip', { data: data })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-在页面中引入"><a href="#4-在页面中引入" class="headerlink" title="4.在页面中引入"></a>4.在页面中引入</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import { getDetail } from "../../api/home";</span><br><span class="line">...</span><br><span class="line">setup(){</span><br><span class="line">	...</span><br><span class="line">	getDetail(data).then((e) =&gt; {</span><br><span class="line">        if (e != null) {</span><br><span class="line">          datas.title = e.data.title;</span><br><span class="line">          datas.content = e.data.content;</span><br><span class="line">        } else {</span><br><span class="line">          datas.title = "";</span><br><span class="line">          datas.content = "";</span><br><span class="line">        }</span><br><span class="line">      });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p><img src="https://img-blog.csdnimg.cn/35db179f75fa46e1a042fa8923ff8fbb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
]]></content>
      <tags>
        <tag>vue.js</tag>
        <tag>前端</tag>
        <tag>开发语言</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实际运用：处理token过期</title>
    <url>/2022/09/19/vue-shi-ji-yun-yong-chu-li-token-guo-qi/</url>
    <content><![CDATA[<br>

<p><strong>后端为了安全，token一般存在有效时间，当token过期，所有请求失效</strong></p>
<h2 id="一、解决方案："><a href="#一、解决方案：" class="headerlink" title="一、解决方案："></a><strong>一、解决方案：</strong></h2><p>1)在请求发起前拦截每个请求，判断token的有效时间是否已经过期，若已过期，则将请求挂起，先刷新token后再继续请求。</p>
<ul>
<li>优点： 在请求前拦截，能节省请求，省流量</li>
<li>缺点： 需要后端额外提供一个token过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败</li>
<li>使用方法：axios.interceptors.request.use() 这个请求前拦截方法</li>
</ul>
<p>2)根据拦截返回后的数据判断，若token过期，先刷新token，再进行一次请求。</p>
<ul>
<li>优点：不需额外的token过期字段，不需判断时间</li>
<li>缺点： 会消耗多一次请求，耗流量</li>
<li>使用方法：axios.interceptors.response.use() 这个响应拦截方法</li>
</ul>
<p><strong>最简单方法：获取到过期code，直接跳到登录页</strong></p>
<h2 id="二、实现方法："><a href="#二、实现方法：" class="headerlink" title="二、实现方法："></a><strong>二、实现方法：</strong></h2><p>1)封装axios基本结构</p>
<ul>
<li>token是存在localStorage中<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//在request.js</span><br><span class="line"></span><br><span class="line">import axios from 'axios'</span><br><span class="line"></span><br><span class="line">// 创建一个实例</span><br><span class="line">const service = axios.create({</span><br><span class="line">    baseURL: process.env.VUE_APP_BASE_API, </span><br><span class="line">    timeout: 5000 // request timeout</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 从localStorage中获取token</span><br><span class="line">function getLocalToken () {</span><br><span class="line">    const token = window.localStorage.getItem('token')</span><br><span class="line">    return token</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span><br><span class="line">service.setToken = (token) =&gt; {</span><br><span class="line">  instance.defaults.headers['X-Token'] = token</span><br><span class="line">  window.localStorage.setItem('token', token)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 拦截返回的数据</span><br><span class="line">service.interceptors.response.use(response =&gt; {</span><br><span class="line">  // 接下来会在这里进行token过期的逻辑处理</span><br><span class="line">  return response</span><br><span class="line">}, error =&gt; {</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">//暴露</span><br><span class="line">export default service</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>假如后端接口token过期返回的code是401</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//获取新的token请求</span><br><span class="line">function refreshToken () {</span><br><span class="line">    return service.post('/refreshtoken').then(res =&gt; res.data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 拦截返回的数据</span><br><span class="line">service.interceptors.response.use(response =&gt; {</span><br><span class="line">  // 接下来会在这里进行token过期的逻辑处理</span><br><span class="line">  const { code } = response.data</span><br><span class="line">  	-----------------------------------------------------------</span><br><span class="line">  	// 说明token过期了,获取新的token</span><br><span class="line">	 if (code === 401) {</span><br><span class="line">		return refreshToken().then(res =&gt; {</span><br><span class="line">		// 刷新token成功，将最新的token更新到header中，同时保存在localStorage中</span><br><span class="line">	      const { token } = res.data</span><br><span class="line">	      service.setToken(token)</span><br><span class="line">	      </span><br><span class="line">	      // 获取当前失败的请求</span><br><span class="line">	      const config = response.config</span><br><span class="line">	      //重置失败请求的配置</span><br><span class="line">	      config.headers['X-Token'] = token</span><br><span class="line">	      config.baseURL = '' "</span><br><span class="line">	      //重试当前请求并返回promise</span><br><span class="line">	      return service(config)</span><br><span class="line">		}).catch( res=&gt;{</span><br><span class="line">			//重新请求token失败，跳转到登录页</span><br><span class="line">			window.location.href = '/login '</span><br><span class="line">		} )</span><br><span class="line">	 }</span><br><span class="line">	 --------------------------------------------------------------</span><br><span class="line">  return response</span><br><span class="line"></span><br><span class="line">}, error =&gt; {</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>2)问题和优化<br>如果token失效时，存在多个请求，这就会导致多次执行刷新token的接口<br><strong>在request.js中用一个变量来标记当前是否正在刷新token的状态，如果正在刷新则不再调用刷新token的接口</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">在request.js</span><br><span class="line"></span><br><span class="line">// 是否正在刷新的标记</span><br><span class="line">let isRefreshing = false</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">// 说明token过期了,获取新的token</span><br><span class="line">if (code === 401) {</span><br><span class="line">	//判断一下状态</span><br><span class="line">	if( !isRefreshing ){</span><br><span class="line">		//修改状态，进入更新token阶段</span><br><span class="line">		isRefreshing = true</span><br><span class="line">		</span><br><span class="line">		return refreshToken().then(res =&gt; {</span><br><span class="line">		// 刷新token成功，将最新的token更新到header中，同时保存在localStorage中</span><br><span class="line">			const { token } = res.data</span><br><span class="line">			service.setToken(token)</span><br><span class="line">			</span><br><span class="line">			// 获取当前失败的请求</span><br><span class="line">			const config = response.config</span><br><span class="line">			//重置失败请求的配置</span><br><span class="line">			config.headers['X-Token'] = token</span><br><span class="line">			config.baseURL = '' "</span><br><span class="line">			//重试当前请求并返回promise</span><br><span class="line">			return service(config)</span><br><span class="line">		}).catch( res=&gt;{</span><br><span class="line">			//重新请求token失败，跳转到登录页</span><br><span class="line">			window.location.href = '/login '</span><br><span class="line">		} ).finally( ()=&gt;{</span><br><span class="line">			//完成之后在关闭状态</span><br><span class="line">			isRefreshing = false</span><br><span class="line">		} )</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>同时发起两个或以上的请求时，其他接口如何重试<br>两个接口几乎同时发起和返回，第一个接口会进入刷新token后重试的流程，而第二个接口需要先存起来，然后等刷新token后再重试。同样，如果同时发起三个请求，此时需要缓存后两个接口，等刷新token后再重试；<br>当第二个过期的请求进来，token正在刷新，我们先将这个请求存到一个数组队列中，想办法让这个请求处于等待中，一直等到刷新token后再逐个重试清空请求队列。<br>将请求存进队列中后，同时返回一个Promise，让这个Promise一直处于Pending状态（即不调用resolve），此时这个请求就会一直等啊等，只要我们不执行resolve，这个请求就会一直在等待。当刷新请求的接口返回来后，我们再调用resolve，逐个重试。<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 是否正在刷新的标记</span><br><span class="line">let isRefreshing = false</span><br><span class="line">// 重试队列，每一项将是一个待执行的函数形式</span><br><span class="line">let requests = []</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">  	// 说明token过期了,获取新的token</span><br><span class="line">	 if (code === 401) {</span><br><span class="line">	 	const config = response.config</span><br><span class="line">	 	//判断一下状态</span><br><span class="line">		if( !isRefreshing ){</span><br><span class="line">			//修改状态，进入更新token阶段</span><br><span class="line">			isRefreshing = true</span><br><span class="line">			// 获取当前的请求</span><br><span class="line">			return refreshToken().then(res =&gt; {</span><br><span class="line">			// 刷新token成功，将最新的token更新到header中，同时保存在localStorage中</span><br><span class="line">		      const { token } = res.data</span><br><span class="line">		      service.setToken(token)</span><br><span class="line">		      </span><br><span class="line">		      //重置失败请求的配置</span><br><span class="line">		      config.headers['X-Token'] = token</span><br><span class="line">		      config.baseURL = '' "</span><br><span class="line">		      </span><br><span class="line">		      //已经刷新了token，将所有队列中的请求进行重试</span><br><span class="line">		      requests.forEach(cb =&gt; cb(token))</span><br><span class="line">		      // 重试完了别忘了清空这个队列</span><br><span class="line">		      requests = []</span><br><span class="line">		      </span><br><span class="line">		      return service(config)</span><br><span class="line">			}).catch( res=&gt;{</span><br><span class="line">				//重新请求token失败，跳转到登录页</span><br><span class="line">				window.location.href = '/login '</span><br><span class="line">			} ).finally( ()=&gt;{</span><br><span class="line">				//完成之后在关闭状态</span><br><span class="line">				isRefreshing = false</span><br><span class="line">			} )</span><br><span class="line">		} else{</span><br><span class="line">			 // 正在刷新token，返回一个未执行resolve的promise</span><br><span class="line">			 return new Promise((resolve) =&gt; {</span><br><span class="line">	         // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span><br><span class="line">		         requests.push((token) =&gt; {</span><br><span class="line">			          config.baseURL = ''</span><br><span class="line">			          config.headers['X-Token'] = token</span><br><span class="line">			          resolve(instance(config))</span><br><span class="line">		       	 })</span><br><span class="line">	     	 })</span><br><span class="line">		}</span><br><span class="line">	 }</span><br><span class="line">	 --------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>使用NVM安装NodeJS并解决npm下载依赖失效问题（最全流程）</title>
    <url>/2022/09/19/shi-yong-nvm-an-zhuang-nodejs-bing-jie-jue-npm-xia-zai-yi-lai-shi-xiao-wen-ti-zui-quan-liu-cheng/</url>
    <content><![CDATA[<p>本人因为刚学习react，需要创建项目。下载过react依赖后才发现黑窗口提示我因node版本过低无法创建项目，怎么办呢？我去网上看了很多node升级的文章，大多数说的是重新去官网下载更高版本，我就跟着他们一步步走，但是很快问题就出现了。先是文章中说应该更改node缓存地址，防止给C盘造成过大压力。这就涉及到更改环境变量，我一顿操作后忽然发现我新安装的node版本查不到。emmmmmm 这是为什么呢？我去看了我的文件夹，发现之前的NodeJs版本是由nvm管理的。哦~~~原来是这样。我立马改道又去搜了nvm管理nodejs怎么下载更高级别的node版本。就这样，我又按照nvm的方式一步步输入命令。OK！nodejs版本下载好了。npm版本也能查到。我终于可以开始我的react之旅了。  但是！！老话说得好，人不能高兴的太早。我发现我的npm失效了，没办法下载任何依赖。我又能怎么办呢，只能改道重新去查询npm失效的解决办法，我看了很多文章，各种方法全试了，最起码在我这他们都不行。具体报错及尝试我就不在这里一一记录了。<br>我说说我的解决办法吧。我最终是决定卸载Nodejs以及nvm，重新走一遍流程。<br>因记录了自己整个解决问题的过程，废话有点多。<strong>大家可直接跳跃至标题（一：NVM介绍）阅读</strong></p>
<p><strong>注：本文编写的NVM+NodeJS安装步骤指引，是基于Windows10、64位操作系统进行的编写说明。</strong></p>
<h1 id="一、NVM介绍"><a href="#一、NVM介绍" class="headerlink" title="一、NVM介绍"></a>一、NVM介绍</h1><p>NVM：Node Version Manage，即Node的版本管理工具。使用NVM，可以很方便地在多个NodeJS版本之间进行切换。</p>
<p>由于项目开发当中，<strong>不同的项目可能依赖不同版本的NodeJS</strong>，这种情况下，<strong>NodeJS版本的切换将会是一件非常麻烦的事情</strong>。因此，<strong>使用NVM管理NodeJS版本就显得尤为重要</strong>。 </p>
<h1 id="二、卸载电脑上现有的NodeJS-及nvm"><a href="#二、卸载电脑上现有的NodeJS-及nvm" class="headerlink" title="二、卸载电脑上现有的NodeJS 及nvm"></a>二、卸载电脑上现有的NodeJS 及nvm</h1><h2 id="卸载nvm"><a href="#卸载nvm" class="headerlink" title="卸载nvm"></a>卸载nvm</h2><p>直接删除nvM所在文件夹就可以了。</p>
<h2 id="卸载NodeJS"><a href="#卸载NodeJS" class="headerlink" title="卸载NodeJS"></a>卸载NodeJS</h2><ol>
<li><p>从卸载程序卸载程序和功能<br> a. 打开控制面板<br> b. 选择程序和功能<br><img src="https://img-blog.csdnimg.cn/7b1d3cff85394f328fc1c685a0b559dd.png"><br> c. 找到Node.js并卸载<br> <img src="https://img-blog.csdnimg.cn/fac98ee374b84df2a749d43a9005c274.png"></p>
</li>
<li><p>检查环境变量<br>将用户变量和系统变量中所有与node有关的全部删除。</p>
</li>
</ol>
<p><strong>注意：不要忘记检查path</strong><br>3. 检查系统盘，寻找这些文件并删除它们（根据您安装的版本，UAC设置和CPU架构，这些可能或可能不存在）：<br>C:\Users{User}\AppData\Roaming\npm（或%appdata%\npm）<br>C:\Users{User}\AppData\Roaming\npm-cache（或%appdata%\npm-cache）<br>4. 重启电脑<br>5. 黑窗口输入以下代码检查是否正确删除</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">nvm -v</span><br><span class="line">node -v</span><br></pre></td></tr></tbody></table></figure>
<h1 id="三、安装NVM和NodeJs"><a href="#三、安装NVM和NodeJs" class="headerlink" title="三、安装NVM和NodeJs"></a>三、安装NVM和NodeJs</h1><h2 id="3-1-下载NVM安装包"><a href="#3-1-下载NVM安装包" class="headerlink" title="3.1 下载NVM安装包"></a>3.1 下载NVM安装包</h2><p>在GitHub上下载NVM的安装包。下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases%EF%BC%8C%E9%80%89%E6%8B%A9%E4%B8%8B%E8%BD%BDnvm-setup.zip%E3%80%82">https://github.com/coreybutler/nvm-windows/releases，选择下载nvm-setup.zip。</a></p>
<p>注：本例中选用的是截至2022年4月12日最新版本的NVM安装包，版本号为1.1.9。 </p>
<h2 id="3-2-安装NVM"><a href="#3-2-安装NVM" class="headerlink" title="3.2 安装NVM"></a>3.2 安装NVM</h2><p>双击nvm-setup.exe文件，进行NVM的安装。<br>(1) 接受协议，下一步。<br>(2) 选择NVM的安装路径。可以按照个人习惯，自行选择安装路径。本例中，按照本人习惯，选择安装在D:\nvm\nvm下。<br><img src="https://img-blog.csdnimg.cn/40f0692c725e482ab9c1da5485a6671a.png"></p>
<p>(3) 选择NodeJS的Symlink (符号链接)文件夹的位置，用于生成NodeJS的映射目录。本例中，按照本人习惯，选择D:\nodejs。</p>
<p>注：<strong>安装前，需确保Symlink文件夹所在的路径不存在</strong>，否则可能安装失败。</p>
<p>(4) 点击安装，等待安装完成。</p>
<p>(5) 配置环境变量。</p>
<p>打开高级系统设置-&gt;环境变量，可以发现，安装成功后，NVM已经自动帮我们配置了环境变量NVM_HOME和NVM_SYMLINK，并且配置了Path的值。<br><img src="https://img-blog.csdnimg.cn/183d4ee9c4ae4c07bb9bcac6b0cbe44a.png"><br>因此，对于1.1.9版本的NVM，环境变量一般情况下无需手动配置。</p>
<p>注：若使用的是免安装版的NVM，可以按照如下方式手动配置环境变量。</p>
<ol>
<li>在用户变量(或系统变量)中，添加变量名NVM_HOME，变量的值为NVM所在的根路径(以本例为例，路径为：D:\Program Files\nvm)； 2. 在用户变量(或系统变量)中，添加变量名NVM_SYMLINK，变量的值为NodeJS的Symlink 文件夹的位置(以本例为例，路径为：D:\Program Files\nodejs)； 3. 在用户变量(或系统变量)的path当中添加两个值：%NVM_HOME%和%NVM_SYMLINK%。</li>
</ol>
<p>(6) 配置NodeJS下载代理镜像（可选）</p>
<p>安装完成后，可以在NVM安装根目录下的setting.txt文件中，配置NodeJS下载代理镜像，解决在线安装NodeJS时速度慢的问题。</p>
<p>注：由于下载速度一般正常，并且可以使用离线安装的方式安装NodeJS，因此配置NodeJS下载镜像地址并不是必须的。由于篇幅有限，这里不再展开介绍。</p>
<p>2.3 验证NVM是否安装成功</p>
<p>安装完成后，打开命令行窗口，输入nvm -v，出现版本号即表示安装成功。</p>
<h2 id="3-3在NVM中安装NodeJS"><a href="#3-3在NVM中安装NodeJS" class="headerlink" title="3.3在NVM中安装NodeJS"></a>3.3在NVM中安装NodeJS</h2><h3 id="3-3-1-nvm安装"><a href="#3-3-1-nvm安装" class="headerlink" title="3.3.1 nvm安装"></a>3.3.1 nvm安装</h3><p>首先，<strong>在使用NVM安装NodeJS前，需要以管理员身份打开命令行窗口。否则，将无法使用nvm use命令切换NPM版本</strong>。</p>
<p>(1) 首先，使用NVM命令 nvm list available，查看可安装的NodeJS版本。建议选择LTS中的版本进行安装（LTS，即Long Term Support，长期支持版本）<br><img src="https://img-blog.csdnimg.cn/5328c8e473fb4d1e8aabf8dda996e2f7.png"><br>注：若要查看完整的可安装版本列表，可访问官网：<a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a>。</p>
<p>(2) 使用NVM命令nvm install，进行对应版本NodeJS的在线安装。</p>
<p>示例 ：如需在线安装16.14.2版本的NodeJS，直接在命令行窗口输入：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">nvm install 16.15.0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-2离线安装NodeJs"><a href="#3-3-2离线安装NodeJs" class="headerlink" title="3.3.2离线安装NodeJs"></a>3.3.2离线安装NodeJs</h3><p>(1) 从官网下载指定版本NodeJS的免安装版离线安装包，下载地址：<a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a>。<br><img src="https://img-blog.csdnimg.cn/8b320edcd4704b52b69c44601d888c9b.png"><br>上图中是Windows 10 64位操作系统，因此选择的是node-v17.6.0-win-x64.zip。<br><img src="https://img-blog.csdnimg.cn/07158792266645a7a36a6369e53a862c.png"><br>(2) 将指定版本的NodeJS免安装版离线安装包，解压后放入到NVM安装路径的根目录下，即可完成离线安装。<br><img src="https://img-blog.csdnimg.cn/33c890bc335f4d729061879f8d380606.png"></p>
<h3 id="3-3-3-版本切换"><a href="#3-3-3-版本切换" class="headerlink" title="3.3.3 版本切换"></a>3.3.3 版本切换</h3><p>若已经成功安装了指定版本的NodeJS，只需要在命令行窗口执行npm use命令，切换对应版本的NodeJS即可。本例中，由于已经安装了16.14.2版本，因此可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">nvm use 17.6.0</span><br></pre></td></tr></tbody></table></figure>
<p>如果执行之后是一串乱码，你需要用管理员身份打开窗口，重新输入上面的话。<br>若操作成功，将出现提示：Now using node v16.15.0 (64-bit)<br><img src="https://img-blog.csdnimg.cn/9208dc58cda34afeba9e0daf03959913.png"><br>如果能够以管理员身份，在命令行窗口成功执行以上命令，那么恭喜你，NVM+NodeJS已经成功安装完成！！！</p>
<h3 id="3-3-4-NVM还有很多常用命令，在此不多做赘述，各位可自行搜索。"><a href="#3-3-4-NVM还有很多常用命令，在此不多做赘述，各位可自行搜索。" class="headerlink" title="3.3.4 NVM还有很多常用命令，在此不多做赘述，各位可自行搜索。"></a>3.3.4 NVM还有很多常用命令，在此不多做赘述，各位可自行搜索。</h3><h1 id="四、解决npm失效问题"><a href="#四、解决npm失效问题" class="headerlink" title="四、解决npm失效问题"></a>四、解决npm失效问题</h1><p>有的人可能到上一步为止问题就解决了。但是也会有一部分人像我一样，运行<code>npm -v</code>报错<code>'npm' 不是内部或外部命令，也不是可运行的程序</code><br>我打开nvm文件夹去看了下，16.15.0里面这些都没有，node_modules文件夹也是空的。。。<br>正常应该是下图所示：<br><img src="https://img-blog.csdnimg.cn/0b378115b8b74c5998003b4e97a54bd5.png"><br><strong>解决办法是：</strong><br><strong>从node官网找对应版本的zip压缩包下来，替换掉这个目录里的东西</strong>，然后就完美解决了，node、npm都没问题，也可以自由切换版本。</p>
<p><code>本文没有详写nodejs 如何指定全局安装路径和缓存路径。各位如果有需要，可自行查找。</code></p>
<p>借阅大佬文章：<a href="https://www.bilibili.com/read/cv16108420">使用NVM安装NodeJS(原创 最全笔记)</a></p>
]]></content>
      <tags>
        <tag>react.js</tag>
        <tag>npm</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue新增 - inheritAttrs &amp; listeners &amp; attrs</title>
    <url>/2022/09/19/guan-yu-vue-xin-zeng-attrs-listeners-inheritattrs/</url>
    <content><![CDATA[<h2 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a><strong>$attrs</strong></h2><ul>
<li>只读属性</li>
<li>包含了父作用域中不作为 props 被识别 (且获取) 的特性绑定 (class 和 style 除外)</li>
<li>可以通过v-bind=”$attrs”传入内部组件</li>
</ul>
<p><strong>包含了父作用域中不作为 props 被识别 (且获取) 的特性绑定 (class 和 style 除外)</strong><br>父组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    // 子组件上绑定了三个值 - happy、peter、attrs</span><br><span class="line">    &lt;child :happy="happy" :peter="peter" **attrs="$attrs"**&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from './child.vue'</span><br><span class="line">export default {</span><br><span class="line">  name: 'TestPage',</span><br><span class="line">  data(){</span><br><span class="line">    return {</span><br><span class="line">      happy: 'happy',</span><br><span class="line">      peter: 'peter'</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  </span><br><span class="line">  components: {</span><br><span class="line">    child</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>子组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: 'child',</span><br><span class="line">  // 只将happy作为prop获取</span><br><span class="line">  props: ['happy'],</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  mounted(){</span><br><span class="line">    console.log(this.$attrs) // {attrs: "$attrs", peter: "peter"}</span><br><span class="line">  },</span><br><span class="line"> };</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>可以通过v-bind=”$attrs”传入内部组件</strong><br>例：向孙子组件传值</p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    // 子组件上绑定了三个值 - happy、peter、attrs</span><br><span class="line">    &lt;child :happy="happy" :peter="peter" attrs="$attrs"&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from './child.vue'</span><br><span class="line">export default {</span><br><span class="line">  name: 'TestPage',</span><br><span class="line">  data(){</span><br><span class="line">    return {</span><br><span class="line">      happy: 'happy',</span><br><span class="line">      peter: 'peter'</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  components: {</span><br><span class="line">    child</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>子组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-child **v-bind="$attrs"**&gt;&lt;/child-child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import childChild from './childChild.vue'</span><br><span class="line">export default {</span><br><span class="line">  name: 'child',</span><br><span class="line">  props: ['happy'],</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  components: {</span><br><span class="line">    childChild</span><br><span class="line">  }</span><br><span class="line"> };</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>孙子组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;peter：{{peter}}&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: 'childChild',</span><br><span class="line">  // 子组件v-bind="$attrs"后，孙子组件可以直接 props: ['peter']</span><br><span class="line">  // props只能获取$attrs中存在的值，如获取 happy，输出为undefined</span><br><span class="line">  props: ['peter'],</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  mounted(){</span><br><span class="line">    console.log(this.peter) // peter</span><br><span class="line">  }</span><br><span class="line"> };</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h3><ul>
<li>只读属性</li>
<li>包含了父作用域中（不含.native修饰器的）v-on时间监听器</li>
<li>可以通过 v-on=”$listeners” 传入内部组件</li>
</ul>
<p> <strong>包含了父作用域中（不含.native修饰器的）v-on时间监听器</strong></p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child @editFather="editFather" @click="testListeners" @testNative.native="testNative"&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from './child.vue'</span><br><span class="line">export default {</span><br><span class="line">  name: 'TestPage',</span><br><span class="line">  components: {</span><br><span class="line">    child</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">    editFather(){},</span><br><span class="line">    testListeners(){},</span><br><span class="line">    testNative(){}</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>子组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: 'child',</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  mounted(){</span><br><span class="line">    console.log(this.$listeners) // { editFather: f, click: f }</span><br><span class="line">  }</span><br><span class="line"> };</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>可以通过 v-on=”$listeners” 传入内部组件</strong><br>例：孙子组件修改父组件的值</p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child :peter="peter" attrs="$attrs" @editFather="editFather"&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from './child.vue'</span><br><span class="line">export default {</span><br><span class="line">  name: 'TestPage',</span><br><span class="line">  data(){</span><br><span class="line">    return {</span><br><span class="line">      peter: 'peter'</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  components: {</span><br><span class="line">    child</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">    editFather(){</span><br><span class="line">      this.peter = 'hello, peter'</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>子组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-child v-bind="$attrs" v-on="$listeners"&gt;&lt;/child-child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import childChild from './childChild.vue'</span><br><span class="line">export default {</span><br><span class="line">  name: 'child',</span><br><span class="line">  props: [],</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  components: {</span><br><span class="line">    childChild</span><br><span class="line">  }</span><br><span class="line"> };</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>孙子组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;peter： {{peter}}&lt;/div&gt;</span><br><span class="line">    &lt;button @click="editFather"&gt;改变peter&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: 'childChild',</span><br><span class="line">  props: ['peter'],</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  methods: {</span><br><span class="line">    editFather(){</span><br><span class="line">      // 孙子组件调用父组件的方法</span><br><span class="line">      this.$emit("editFather")</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"> };</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h3><ul>
<li>boolean类型</li>
<li>默认值：true</li>
<li>true：父作用域不作为 props 被识别 (且获取) 的特性将会被“回退”且作为普通的HTML特性应用在子组件的根元素上。</li>
<li>false：去掉默认行为</li>
<li>该属性不影响<code>class\style</code></li>
<li>该属性不影响<code>attr</code> ， 无 论 设 置 为<code>true</code>或<code> false</code>， 子 组 件 都 可 以 通 过 attrs，无论设置为true或false，子组件都可以通过attrs，无论设置为true或false，子组件都可以通过attrs获取到父组件传过来的属性值</li>
</ul>
<h3 id="inheritAttrs-true"><a href="#inheritAttrs-true" class="headerlink" title="inheritAttrs: true"></a>inheritAttrs: true</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 父组件引用</span><br><span class="line">&lt;customEvent</span><br><span class="line">  @click="testEvent" testAttr='testAttr_value' testAttr2='testAttr2' class="bushiba?"</span><br><span class="line">  @myEvent="emitFN" ref="childtest"</span><br><span class="line">&gt;</span><br><span class="line">&lt;/customEvent&gt;</span><br><span class="line"> </span><br><span class="line">// 子组件 customEvent</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt; </span><br><span class="line">    根节点这个 div 标签将继承非props的所有 attr 和 事件；</span><br><span class="line">    (vue内置的特殊attribute是不会继承的)</span><br><span class="line"> </span><br><span class="line">    &lt;div&gt;单节点组件1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;单节点组件2&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import { defineComponent } from 'vue'</span><br><span class="line">export default defineComponent({</span><br><span class="line">  inheritAttrs: true,</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ba2a102f1909472486d5167c744fb9db.png" alt="在这里插入图片描述"></p>
<h3 id="inheritAttrs-false"><a href="#inheritAttrs-false" class="headerlink" title="inheritAttrs: false"></a>inheritAttrs: false</h3><p>设置为false后，不论单节点还是多节点的组件，都不会继承任何 attr 和 事件！<br><img src="https://img-blog.csdnimg.cn/19be332b43104d9b8b6d0b7270a574b9.png" alt="在这里插入图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>前后端分离开发之权限篇及VUE路由守卫</title>
    <url>/2022/09/19/qian-hou-duan-fen-chi-kai-fa-zhi-quan-xian-pian-ji-vue-lu-you-shou-wei-next-next-to-replace-true-next-shuo-ming/</url>
    <content><![CDATA[<p>写项目过程中在权限部分遇到了不少有关<code>next()</code>的问题，解决完之后发现对于权限篇的整体逻辑清晰不少，在这里记录一下。<br>首先是路由守卫，是不是感觉简简单单</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">beforeEach((to, from, next) =&gt; {</span><br><span class="line">	to // 要去的路由</span><br><span class="line">	from // 当前路由</span><br><span class="line">	next() // 放行的意思</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是在看别的项目时常常能看到<code>next('/logon')</code>、<code>next(to)</code> 或者 <code>next({ ...to, replace: true })</code> 这又是啥意思呢</p>
<p>其实在路由守卫中，只有<code>next()</code>是放行，其他的诸如：<code>next('/logon')</code>、<code>next(to) </code>或者 <code>next({ ...to, replace: true })</code>都不是放行，而是：中断当前导航，执行新的导航</p>
<h3 id="可以这么理解："><a href="#可以这么理解：" class="headerlink" title="可以这么理解："></a><strong>可以这么理解：</strong></h3><p><code>next()</code>是放行，但是如果<code>next()</code>里有参数的话，<code>next()</code>就像被重载一样，就有了不同的功能。</p>
<p>而对于上面说的中断当前导航，执行新的导航打个比方：</p>
<p>现在我有一个守卫，在守卫中我使用<code>next('/logon')</code>，肯定有同学认为是会直接跳转到<code>/logon</code>路由：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">beforeEach((to, from, next) =&gt; {</span><br><span class="line">  next('/logon')</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然而年轻人不讲武德，执行时需要这么看：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">beforeEach((to, from, next) =&gt; {</span><br><span class="line">  beforeEach(('/logon', from, next) =&gt; {</span><br><span class="line">  	 beforeEach(('/logon', from, next) =&gt; {</span><br><span class="line">  	 	 beforeEach(('/logon', from, next) =&gt; {</span><br><span class="line">  	 	 	beforeEac...  // 一直循环下去...... , 因为我们没有使用 next() 放行</span><br><span class="line"> 		}</span><br><span class="line"> 	 }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果把这个守卫改一下，当我在地址栏输入<code>/home</code>时</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">beforeEach((to, from, next) =&gt; {</span><br><span class="line">   if(to.path === '/home') {</span><br><span class="line">   	next('/logon')</span><br><span class="line">   } else {</span><br><span class="line">    // 如果要去的地方不是 /home ， 就放行</span><br><span class="line">   	next()</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我本来要去<code>/home</code>路由，因此执行了第一次 <code>beforeEach((to, from, next)</code></p>
<p>但是这个路由守卫中判断了如果要去的地方是<code>'/home'</code>，就执行<code>next('/logon')</code>，</p>
<p>所以想要访问<code>/home</code>可以这么看</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">beforeEach((to, from, next) =&gt; {</span><br><span class="line">   beforeEach(('/logon', from, next) =&gt; {</span><br><span class="line">     next()  // 现在要去的地方不是 /home ， 因此放行</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="正以为如此很多人在使用动态添加路由addRoutes-会遇到下面的情况："><a href="#正以为如此很多人在使用动态添加路由addRoutes-会遇到下面的情况：" class="headerlink" title="正以为如此很多人在使用动态添加路由addRoutes()会遇到下面的情况："></a>正以为如此很多人在使用动态添加路由addRoutes()会遇到下面的情况：</h4><p>在addRoutes()之后第一次访问被添加的路由会白屏，这是因为刚刚addRoutes()就立刻访问被添加的路由，然而此时addRoutes()没有执行结束，因而找不到刚刚被添加的路由导致白屏。因此需要从新访问一次路由才行。</p>
<p>该如何解决这个问题 ?<br>此时就要使用<code>next({ ...to, replace: true })</code>来确保<code>addRoutes()</code>时动态添加的路由已经被完全加载上去。</p>
<p><code>next({ ...to, replace: true })</code>中的<code>replace: true</code>只是一个设置信息，告诉VUE本次操作后，不能通过浏览器后退按钮，返回前一个路由。</p>
<p>因此<code>next({ ...to, replace: true })</code>可以写成<code>next({ ...to })</code>，不过你应该不希望用户在<code>addRoutes()</code>还没有完成的时候，可以点击浏览器回退按钮搞事情吧。</p>
<p>其实<code>next({ ...to })</code>的执行很简单，它会判断：</p>
<p>如果参数to不能找到对应的路由的话，就再执行一次<code>beforeEach((to, from, next)</code>直到其中的<code>next({ ...to})</code>能找到对应的路由为止。</p>
<p>也就是说此时<code>addRoutes()</code>已经完成啦，找到对应的路由之后，接下来将执行前往对应路由的<code>beforeEach((to, from, next)</code> ，因此需要用代码来判断这一次是否就是前往对应路由的<code>beforeEach((to, from, next)</code>，如果是，就执行<code>next()</code>放行。</p>
<p>如果守卫中没有正确的放行出口的话，会一直<code>next({ ...to}</code>)进入死循环 !!!</p>
<p>因此你还需要确保在当<code>addRoutes()</code>已经完成时，所执行到的这一次<code>beforeEach((to, from, next)</code>中有一个正确的<code>next()</code>方向出口。</p>
<h4 id="因此想实现动态添加路由的操作的话，代码应该是这样的："><a href="#因此想实现动态添加路由的操作的话，代码应该是这样的：" class="headerlink" title="因此想实现动态添加路由的操作的话，代码应该是这样的："></a>因此想实现动态添加路由的操作的话，代码应该是这样的：</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; {</span><br><span class="line"> const token = sessionStorage.getItem('access_token')</span><br><span class="line"> // 存在 token 说明已经登录</span><br><span class="line"> if (token) {</span><br><span class="line">   // 登录过就不能访问登录界面，需要中断这一次路由守卫，执行下一次路由守卫，并且下一次守卫的to是主页'</span><br><span class="line">   if (to.path === '/login') {</span><br><span class="line">     next({ path: '/' })</span><br><span class="line">   }</span><br><span class="line">   // 保存在store中路由不为空则放行 (如果执行了刷新操作，则 store 里的路由为空，此时需要重新添加路由)</span><br><span class="line">   if (store.getters.getRoutes.length || to.name != null) {</span><br><span class="line">     //放行</span><br><span class="line">     next()</span><br><span class="line">   } else {</span><br><span class="line">     // 将路由添加到 store 中，用来标记已添加动态路由</span><br><span class="line">     store.commit('ADD_ROUTER', '需要添加的路由')</span><br><span class="line">     router.addRoutes('需要添加的路由')</span><br><span class="line">     // 如果 addRoutes 并未完成，路由守卫会一层一层的执行执行，直到 addRoutes 完成，找到对应的路由</span><br><span class="line">     next({ ...to, replace: true })</span><br><span class="line">   }</span><br><span class="line"> } else {</span><br><span class="line">   // 未登录时，注意 ：在这里也许你的项目不只有 logon 不需要登录 ，register 等其他不需要登录的页面也需要处理</span><br><span class="line">   if (to.path !== '/logon') {</span><br><span class="line">     next({ path: '/logon' })</span><br><span class="line">   } else {</span><br><span class="line">     next()</span><br><span class="line">   }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p><strong>核心的权限判断方法到这里就基本已经实现了。逻辑大致如此，至于源码，贴到下面~</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import router from './routers';</span><br><span class="line">import store from '@/store';</span><br><span class="line">import NProgress from 'nprogress'; // progress bar</span><br><span class="line">import 'nprogress/nprogress.css';// progress bar style</span><br><span class="line">import { getToken } from '@/utils/auth'; // getToken from cookie</span><br><span class="line">import { buildMenus } from '@api/menu';</span><br><span class="line">import { filterAsyncRouter } from '@/store/modules/permission';</span><br><span class="line"></span><br><span class="line">NProgress.configure({ showSpinner: false });// NProgress Configuration</span><br><span class="line"></span><br><span class="line">const whiteList = ['/login', '/register', '/about', '/page/home'];      // no redirect whitelist</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; {</span><br><span class="line">    NProgress.start();</span><br><span class="line">    if (getToken()) {</span><br><span class="line">    // 已登录且要跳转的页面是登录页</span><br><span class="line">        if (to.path === '/login') {</span><br><span class="line">            next({ path: '/' });</span><br><span class="line">            NProgress.done();</span><br><span class="line">        } else {</span><br><span class="line">            if (judgeObj(store.getters.user)) { // 判断当前用户是否已拉取完user_info信息</span><br><span class="line">                store.dispatch('user/GetInfo').then(res =&gt; { // 拉取user_info</span><br><span class="line">                    // 动态路由，拉取菜单</span><br><span class="line">                    loadMenus(next, to);</span><br><span class="line">                }).catch((err) =&gt; {</span><br><span class="line">                    console.log(err);</span><br><span class="line">                    store.dispatch('user/LogOut').then(() =&gt; {</span><br><span class="line">                        location.reload(); // 为了重新实例化vue-router对象 避免bug</span><br><span class="line">                    });</span><br><span class="line">                });</span><br><span class="line">                // 登录时未拉取 菜单，在此处拉取</span><br><span class="line">            } else if (store.getters.loadMenus) {</span><br><span class="line">                // 修改成false，防止死循环</span><br><span class="line">                store.dispatch('user/updateLoadMenus').then(res =&gt; {});</span><br><span class="line">                loadMenus(next, to);</span><br><span class="line">            } else {</span><br><span class="line">                next();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } else {</span><br><span class="line">    /* has no token*/</span><br><span class="line">        console.log('no token', to.path);</span><br><span class="line">        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入</span><br><span class="line">            next();</span><br><span class="line">        } else {</span><br><span class="line">            next(`/page/home?redirect=${to.fullPath}`); // 否则全部重定向到首页</span><br><span class="line">            NProgress.done();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为空对象</span><br><span class="line"> * @param {*} obj</span><br><span class="line"> * @returns</span><br><span class="line"> */</span><br><span class="line">function judgeObj(obj) {</span><br><span class="line">    if (obj &amp;&amp; Object.keys(obj).length === 0) return true;</span><br><span class="line">    else return false;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export const loadMenus = (next, to) =&gt; {</span><br><span class="line">    // 通过接口动态获取数据库保存的路由表</span><br><span class="line">    buildMenus().then(res =&gt; {</span><br><span class="line">        if (res.data) {</span><br><span class="line">        //filterAsyncRouter()  根据需求自己写的方法，遍历后台传来的路由字符串，转换为组件对象</span><br><span class="line">            const asyncRouter = filterAsyncRouter(res.data);</span><br><span class="line">            asyncRouter.push({ path: '*', redirect: '/404', hidden: true });</span><br><span class="line">            store.dispatch('permission/GenerateRoutes', asyncRouter).then(() =&gt; { // 存储路由</span><br><span class="line">                router.addRoutes(asyncRouter); // 动态添加可访问路由表</span><br><span class="line">                next({ ...to, replace: true });</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">router.afterEach(() =&gt; {</span><br><span class="line">    NProgress.done(); // finish progress bar</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>vue.js</tag>
        <tag>javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>正确理解闭包及闭包使用场景</title>
    <url>/2022/09/19/zheng-que-li-jie-bi-bao-ji-bi-bao-shi-yong-chang-jing/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/00d7a66689c0458fbee6649a256abf82.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2VyZW5kaXBpdHlN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>
<h1 id="一、闭包的特性"><a href="#一、闭包的特性" class="headerlink" title="一、闭包的特性"></a>一、闭包的特性</h1><ol>
<li>函数嵌套函数 </li>
<li>函数内部可以引用外部的参数和变量 </li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
<h1 id="二、闭包的定义及其优缺点"><a href="#二、闭包的定义及其优缺点" class="headerlink" title="二、闭包的定义及其优缺点"></a>二、闭包的定义及其优缺点</h1><p><strong>定义：</strong><br>闭包 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量</p>
<p><strong>缺点：</strong><br>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
<p><strong>存在闭包的原因：</strong><br>内部的函数存在外部作用域的引用就会导致闭包。</p>
<p>闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。<br>一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！</p>
<h1 id="三、嵌套函数的闭包"><a href="#三、嵌套函数的闭包" class="headerlink" title="三、嵌套函数的闭包"></a>三、嵌套函数的闭包</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function aaa() {  </span><br><span class="line">  var a = 1;  </span><br><span class="line">  return function(){</span><br><span class="line">   alert(a++)</span><br><span class="line">  };  </span><br><span class="line">}         </span><br><span class="line">var fun = aaa();  </span><br><span class="line">fun();// 1 执行后 a++，，然后a还在~  </span><br><span class="line">fun();// 2   </span><br><span class="line">fun = null;//a被回收！！ </span><br></pre></td></tr></tbody></table></figure>
<p><strong>闭包</strong>会使变量始终保存在内存中，如果不当使用会增大内存消耗。</p>
<h1 id="四、javascript的垃圾回收原理"><a href="#四、javascript的垃圾回收原理" class="headerlink" title="四、javascript的垃圾回收原理"></a>四、javascript的垃圾回收原理</h1><p> 不同的编程语言管理内存的方式各不相同。一些高级编程语言的解释器或运行时嵌入了“垃圾回收器”，通过算法可自动的进行内存的分配与释放管理（比如 JavaScript、Java、C# 等）。另一些则寄希望于开发者自己手动地进行内存的分配与释放管理（比如 C/C++ 等）。<br>而JavaScript 是通过垃圾回收器来进行内存管理，其实现是基于标记-清除算法。而这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。其假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。在标记过程，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。标记完成后就进行清除过程。（可达内存被标记，其余的被当作垃圾回收。）</p>
<p>（1）、在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收；<br>（2）、如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</p>
<h1 id="五、使用闭包的好处"><a href="#五、使用闭包的好处" class="headerlink" title="五、使用闭包的好处"></a>五、使用闭包的好处</h1><p>那么使用闭包有什么好处呢？使用闭包的好处是：</p>
<ol>
<li>希望一个变量长期驻扎在内存中 </li>
<li>避免全局变量的污染 </li>
<li>私有成员的存在</li>
</ol>
<h1 id="六、使用闭包的情况"><a href="#六、使用闭包的情况" class="headerlink" title="六、使用闭包的情况"></a>六、使用闭包的情况</h1><p>你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。</p>
<h2 id="6-1-return-函数作为返回值"><a href="#6-1-return-函数作为返回值" class="headerlink" title="6.1 return 函数作为返回值"></a>6.1 return 函数作为返回值</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function fn(){</span><br><span class="line">  var max=10;</span><br><span class="line">  </span><br><span class="line">  return function bar(x) {</span><br><span class="line">    if(x&gt; max){</span><br><span class="line">      console.log(x)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var f1=fn();</span><br><span class="line">f1(15);</span><br></pre></td></tr></tbody></table></figure>
<p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。</p>
<h2 id="6-2-函数作为参数被传递"><a href="#6-2-函数作为参数被传递" class="headerlink" title="6.2 函数作为参数被传递"></a>6.2 函数作为参数被传递</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var max =10,</span><br><span class="line">fn = function(x){</span><br><span class="line">	if(x &gt; max){</span><br><span class="line">    console.log(x);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">(function (f) {</span><br><span class="line">  var max =100;</span><br><span class="line">  f(15);</span><br><span class="line">})(fn);</span><br></pre></td></tr></tbody></table></figure>
<p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p>
<p>讲自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。</p>
<h2 id="6-3-IIFE（自执行函数）"><a href="#6-3-IIFE（自执行函数）" class="headerlink" title="6.3 IIFE（自执行函数）"></a>6.3 IIFE（自执行函数）</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var n = '林一一';</span><br><span class="line">(function p(){</span><br><span class="line">    console.log(n)</span><br><span class="line">})()</span><br><span class="line">/* 输出</span><br><span class="line">*   林一一</span><br><span class="line">/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-4-循环赋值"><a href="#6-4-循环赋值" class="headerlink" title="6.4 循环赋值"></a>6.4 循环赋值</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">for(var i = 0; i&lt;10; i++){</span><br><span class="line">  (function(j){</span><br><span class="line">       setTimeout(function(){</span><br><span class="line">        console.log(j)</span><br><span class="line">    }, 1000) </span><br><span class="line">  })(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为存在闭包的原因上面能依次输出1~10，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 i++ 到 10时，异步代码才开始执行此时的 i=10 输出的都是 10。</p>
<h2 id="6-5-使用回调函数"><a href="#6-5-使用回调函数" class="headerlink" title="6.5 使用回调函数"></a>6.5 使用回调函数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">window.name = '林一一'</span><br><span class="line">setTimeout(function timeHandler(){</span><br><span class="line">  console.log(window.name);</span><br><span class="line">}, 100)</span><br></pre></td></tr></tbody></table></figure>

<h1 id="七、内存泄露问题"><a href="#七、内存泄露问题" class="headerlink" title="七、内存泄露问题"></a>七、内存泄露问题</h1><p>什么是内存泄漏？<br>应用程序不再用到的内存，由于某些原因，没有及时释放，就叫做内存泄漏。</p>
<p>由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function closure(){</span><br><span class="line">    var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中</span><br><span class="line">    oDiv.onclick = function () {</span><br><span class="line">        alert('oDiv.innerHTML');//这里用oDiv导致内存泄露</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line">closure();</span><br><span class="line">//最后应将oDiv解除引用来避免内存泄露</span><br><span class="line"></span><br><span class="line">function closure(){</span><br><span class="line">    var oDiv = document.getElementById('oDiv');</span><br><span class="line">    var test = oDiv.innerHTML;</span><br><span class="line">    oDiv.onclick = function () {</span><br><span class="line">        alert(test);</span><br><span class="line">    };</span><br><span class="line">    oDiv = null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="八、闭包的销毁"><a href="#八、闭包的销毁" class="headerlink" title="八、闭包的销毁"></a>八、闭包的销毁</h1><pre><code>const outerFn = () =&gt; {
    let count = 0;
    const innerFn = () =&gt; {
        console.log('count', ++count);
    }
    return innerFn;
}

let closure = outerFn(); // 创建第一个闭包
 closure();
closure();
closure = outerFn(); // 销毁第一个闭包，创建第二个闭包
closure();
closure();
closure = null; // 销毁闭包
// 输出结果：
// count 1
// count 2
// count 1
// count 2
</code></pre>
<p>由上面的例子可以看出来，当第二次为closure赋值后，再次执行2次closure()时，count的结果并不会变成3，4，而是又变回了1，2。<br>这表示着，当第二次赋值的时候，第一个闭包就会被垃圾回收销毁掉，而第三次赋值为null时，则是把第二次的闭包也销毁了。</p>
<p>简单的总结：</p>
<ul>
<li>关于闭包的销毁<ul>
<li>可在模块或应用结束后来进行空赋值处理，进行销毁，比如上面的：closure = null</li>
<li>等待页面被关闭，才会被销毁。</li>
</ul>
</li>
<li>至于为什么会要这么处理才会被销毁呢？具体的话可以网上找一下 javascript 回收机制，有兴趣的童鞋可以去了解了解。</li>
</ul>
<h1 id="九、新增"><a href="#九、新增" class="headerlink" title="九、新增"></a>九、新增</h1><p>很多初学者学了闭包后，可能也不懂到底在哪里才有用到，甚至不懂闭包到底有啥用。<br>其实你写的每一个js函数都是闭包，一个js函数的顶层作用域就是window对象，js的执行环境本身就是一个scope（浏览器的window/node的global），我们通常称之为全局作用域。每个函数，不论多深，都可以认为是全局scope的子作用域，可以理解为闭包。</p>
<h1 id="十、必刷题"><a href="#十、必刷题" class="headerlink" title="十、必刷题"></a>十、必刷题</h1><p>一、for 循环和闭包(号称必刷题)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) {</span><br><span class="line">  data[i] = function () {</span><br><span class="line">    console.log(i);</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]()</span><br><span class="line">/* 输出</span><br><span class="line">    3</span><br><span class="line">    3</span><br><span class="line">    3</span><br><span class="line">/</span><br></pre></td></tr></tbody></table></figure>
<p>这里的 i 是全局下的 i，共用一个作用域，当函数被执行的时候这时的 i=3，导致输出的结构都是3。</p>
<p>● 写法1：自执行函数和闭包(使用闭包改善上面的写法达到预期效果)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 3; i++) {</span><br><span class="line">    (function(j){</span><br><span class="line">      setTimeout( data[j] = function () {</span><br><span class="line">        console.log(j);</span><br><span class="line">      }, 0)</span><br><span class="line">    })(i)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]()</span><br></pre></td></tr></tbody></table></figure>
<p>● 写法2：使用 let</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 3; i++) {</span><br><span class="line">  data[i] = function () {</span><br><span class="line">    console.log(i);</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>取消el-upload自带动画效果及图片不裁剪功能</title>
    <url>/2022/09/19/qu-xiao-el-upload-zi-dai-dong-hua-xiao-guo-ji-tu-pian-bu-cai-jian-gong-neng/</url>
    <content><![CDATA[<p>在应用el-upload所在页面加上如下代码，可以取消过渡效果，并且更改图片显示方式</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*去除upload组件过渡效果*/</span></span><br><span class="line">.<span class="property">el</span>-upload-list__item {</span><br><span class="line">  <span class="attr">transition</span>: none !important;</span><br><span class="line">}</span><br><span class="line"> .<span class="property">el</span>-upload-list__item-thumbnail {</span><br><span class="line">    <span class="comment">/* 图片在方框内显示长边 */</span></span><br><span class="line">    object-<span class="attr">fit</span>: scale-down !important;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果加上后仍然没有效果，可以加上::v-deep深度选择器</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*去除upload组件过渡效果*/</span></span><br><span class="line">::v-deep .<span class="property">el</span>-upload-list__item {</span><br><span class="line">  <span class="attr">transition</span>: none !important;</span><br><span class="line">}</span><br><span class="line">::v-deep .<span class="property">el</span>-upload-list__item-thumbnail {</span><br><span class="line">    <span class="comment">/* 图片在方框内显示长边 */</span></span><br><span class="line">    object-<span class="attr">fit</span>: scale-down !important;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一起试试吧！！</p>
]]></content>
      <tags>
        <tag>vue.js</tag>
        <tag>动画</tag>
        <tag>css3</tag>
      </tags>
  </entry>
</search>
